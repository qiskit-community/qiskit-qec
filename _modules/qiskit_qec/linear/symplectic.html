<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <!-- Generated with Sphinx 7.4.7 and Furo 2024.08.06 -->
        <title>qiskit_qec.linear.symplectic - Qiskit QEC 0.0.0</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=3ee1c6c6" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/qiskit-sphinx-theme.css?v=8ff9dcb6" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?v=302659d7" />
    <link rel="stylesheet" type="text/css" href="../../../_static/gallery.css" />
    
    


<style>
  body {
    --color-code-background: #ffffff;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&family=IBM+Plex+Sans:ital,wght@0,400;0,600;1,400;1,600&display=swap" rel="stylesheet"></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M14 2H2C1.73478 2 1.48043 2.10536 1.29289 2.29289C1.10536 2.48043 1 2.73478 1 3V13C1 13.2652 1.10536 13.5196 1.29289 13.7071C1.48043 13.8946 1.73478 14 2 14H14C14.2652 14 14.5196 13.8946 14.7071 13.7071C14.8946 13.5196 15 13.2652 15 13V3C15 2.73478 14.8946 2.48043 14.7071 2.29289C14.5196 2.10536 14.2652 2 14 2V2ZM2 3H10V13H2V3ZM14 13H11V3H14V13Z" fill="currentColor"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M14 3H2V4H14V3Z" fill="currentColor"/>
      <path d="M14 12H2V13H14V12Z" fill="currentColor"/>
      <path d="M14 6H2V7H14V6Z" fill="currentColor"/>
      <path d="M14 9H2V10H14V9Z" fill="currentColor"/>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M11 8L6.00005 13L5.30005 12.3L9.60005 8L5.30005 3.7L6.00005 3L11 8Z" fill="currentColor"/>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M15 13H1V14H15V13Z" fill="currentColor"/>
      <path d="M12.7 4.5C13.1 4.1 13.1 3.5 12.7 3.1L10.9 1.3C10.5 0.9 9.9 0.9 9.5 1.3L2 8.8V12H5.2L12.7 4.5ZM10.2 2L12 3.8L10.5 5.3L8.7 3.5L10.2 2ZM3 11V9.2L8 4.2L9.8 6L4.8 11H3Z" fill="currentColor"/>
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M11 13.0002C11.5523 13.0002 12 12.5525 12 12.0002C12 11.4479 11.5523 11.0002 11 11.0002C10.4477 11.0002 10 11.4479 10 12.0002C10 12.5525 10.4477 13.0002 11 13.0002Z" fill="currentColor"/>
      <path d="M14.8884 11.7394C14.5795 10.9524 14.0464 10.2734 13.3552 9.78646C12.664 9.29954 11.8451 9.02615 11 9.00017C10.1549 9.02615 9.33604 9.29954 8.64484 9.78646C7.95365 10.2734 7.42052 10.9524 7.11155 11.7394L7 12.0002L7.11155 12.2609C7.42052 13.0479 7.95365 13.727 8.64484 14.2139C9.33604 14.7008 10.1549 14.9742 11 15.0002C11.8451 14.9742 12.664 14.7008 13.3552 14.2139C14.0464 13.727 14.5795 13.0479 14.8884 12.2609L15 12.0002L14.8884 11.7394ZM11 14.0002C10.6044 14.0002 10.2178 13.8829 9.88886 13.6631C9.55996 13.4433 9.30362 13.131 9.15224 12.7655C9.00087 12.4001 8.96126 11.998 9.03843 11.61C9.1156 11.222 9.30608 10.8657 9.58579 10.586C9.86549 10.3063 10.2219 10.1158 10.6098 10.0386C10.9978 9.96143 11.3999 10.001 11.7654 10.1524C12.1308 10.3038 12.4432 10.5601 12.6629 10.889C12.8827 11.2179 13 11.6046 13 12.0002C12.9994 12.5304 12.7885 13.0388 12.4136 13.4137C12.0386 13.7887 11.5303 13.9996 11 14.0002Z" fill="currentColor"/>
      <path d="M6 14.0002H4V2.00017H8V5.00017C8.00077 5.26515 8.10637 5.51906 8.29374 5.70643C8.48111 5.8938 8.73502 5.99941 9 6.00017H12V8.00017H13V5.00017C13.0018 4.93446 12.9893 4.86913 12.9634 4.80871C12.9375 4.74828 12.8988 4.6942 12.85 4.65017L9.35 1.15017C9.30599 1.10134 9.2519 1.06263 9.19147 1.03674C9.13104 1.01084 9.06572 0.998364 9 1.00017H4C3.73502 1.00094 3.48111 1.10654 3.29374 1.29391C3.10637 1.48128 3.00077 1.73519 3 2.00017V14.0002C3.00077 14.2652 3.10637 14.5191 3.29374 14.7064C3.48111 14.8938 3.73502 14.9994 4 15.0002H6V14.0002ZM9 2.20017L11.8 5.00017H9V2.20017Z" fill="currentColor"/>
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">Qiskit QEC 0.0.0</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  
  <span class="sidebar-brand-text">Qiskit QEC 0.0.0</span>
  
</a>
<form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Home</a></li>
</ul>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Tutorials</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/QEC_Framework_IEEE_2022.html">Qiskit QEC Software Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/QEC_Framework_IEEE_2022.html#Installation-guide">Installation guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/QEC_Framework_IEEE_2022.html#Quantum-Error-Correction">Quantum Error Correction</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../how_tos/index.html">How-to Guides</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of How-to Guides</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../how_tos/1-how-to-create-codes.html">How-to: Create Codes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../how_tos/2-how-to-work-with-shape-objects.html">How-to: work with geometry objects</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../apidocs/index.html">API References</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of API References</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../apidocs/analysis.html">Analysis (<code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit_qec.analysis</span></code>)</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../apidocs/circuits.html">Circuits (<code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit_qec.circuits</span></code>)</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of Circuits (qiskit_qec.circuits)</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.circuits.CodeCircuit.html">CodeCircuit</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.circuits.RepetitionCodeCircuit.html">RepetitionCodeCircuit</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.circuits.ArcCircuit.html">ArcCircuit</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.circuits.SurfaceCodeCircuit.html">SurfaceCodeCircuit</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.circuits.CSSCodeCircuit.html">CSSCodeCircuit</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../apidocs/codes.html">Codes (<code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit_qec.codes</span></code>)</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of Codes (qiskit_qec.codes)</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.codes.QECCode.html">QECCode</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.codes.StabSubSystemCode.html">StabSubSystemCode</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.codes.CodeLibrary.html">CodeLibrary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.codes.CodeLibrarian.html">CodeLibrarian</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.codes.small_code.html">qiskit_qec.codes.small_code</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.codes.all_small_codes.html">qiskit_qec.codes.all_small_codes</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../apidocs/decoders.html">Decoders (<code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit_qec.decoders</span></code>)</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle navigation of Decoders (qiskit_qec.decoders)</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.decoders.DecodingGraph.html">DecodingGraph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.decoders.UnionFindDecoder.html">UnionFindDecoder</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../apidocs/geometry.html">Geometry (<code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit_qec.geometry</span></code>)</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle navigation of Geometry (qiskit_qec.geometry)</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.geometry.GeometryBounds.html">GeometryBounds</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.geometry.Lattice.html">Lattice</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.geometry.Manifold.html">Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.geometry.Plane.html">Plane</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.geometry.Shape.html">Shape</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.geometry.TwoManifold.html">TwoManifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.geometry.Edge.html">Edge</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.geometry.Face.html">Face</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.geometry.QubitCount.html">QubitCount</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.geometry.QubitData.html">QubitData</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.geometry.ShapeObject.html">ShapeObject</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.geometry.Shell.html">Shell</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.geometry.Vertex.html">Vertex</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.geometry.WireFrame.html">WireFrame</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.geometry.Tile.html">Tile</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.geometry.CheckerBoardTile.html">CheckerBoardTile</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.geometry.DiagonalBarTile.html">DiagonalBarTile</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.geometry.DiagonalHourGlassTile.html">DiagonalHourGlassTile</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.geometry.HexagonTile.html">HexagonTile</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.geometry.OctaSquareTile.html">OctaSquareTile</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.geometry.SquareDiamondTile.html">SquareDiamondTile</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.geometry.Tiling.html">Tiling</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.geometry.TileFactory.html">TileFactory</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../apidocs/info.html">Info (<code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit_qec.info</span></code>)</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><div class="visually-hidden">Toggle navigation of Info (qiskit_qec.info)</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.info.Properties.html">Properties</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../apidocs/linear.html">Linear (<code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit_qec.linear</span></code>)</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><div class="visually-hidden">Toggle navigation of Linear (qiskit_qec.linear)</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.linear.create_lambda_matrix.html">qiskit_qec.linear.create_lambda_matrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.linear.augment_mat.html">qiskit_qec.linear.augment_mat</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.linear.rref.html">qiskit_qec.linear.rref</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.linear.rank.html">qiskit_qec.linear.rank</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.linear.rref_complete.html">qiskit_qec.linear.rref_complete</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.linear.all_commute.html">qiskit_qec.linear.all_commute</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.linear.symplectic_product.html">qiskit_qec.linear.symplectic_product</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.linear.make_commute_hyper.html">qiskit_qec.linear.make_commute_hyper</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.linear.locate_hyper_partner.html">qiskit_qec.linear.locate_hyper_partner</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.linear.build_hyper_partner.html">qiskit_qec.linear.build_hyper_partner</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.linear.symplectic_gram_schmidt.html">qiskit_qec.linear.symplectic_gram_schmidt</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.linear.is_symplectic_matrix_form.html">qiskit_qec.linear.is_symplectic_matrix_form</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.linear.is_symplectic_vector_form.html">qiskit_qec.linear.is_symplectic_vector_form</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.linear.is_symplectic_form.html">qiskit_qec.linear.is_symplectic_form</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.linear.is_hyper_form.html">qiskit_qec.linear.is_hyper_form</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.linear.is_center.html">qiskit_qec.linear.is_center</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.linear.is_same_span.html">qiskit_qec.linear.is_same_span</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.linear.is_stabilizer_group.html">qiskit_qec.linear.is_stabilizer_group</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../apidocs/operators.html">Operators (<code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit_qec.operators</span></code>)</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" role="switch" type="checkbox"/><label for="toctree-checkbox-10"><div class="visually-hidden">Toggle navigation of Operators (qiskit_qec.operators)</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.operators.PauliList.html">PauliList</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.operators.Pauli.html">Pauli</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.operators.BasePauli.html">BasePauli</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../apidocs/structures.html">Structures (<code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit_qec.structures</span></code>)</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" role="switch" type="checkbox"/><label for="toctree-checkbox-11"><div class="visually-hidden">Toggle navigation of Structures (qiskit_qec.structures)</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.structures.Group.html">Group</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.structures.GaugeGroup.html">GaugeGroup</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../apidocs/utils.html">Utils (<code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit_qec.utils</span></code>)</a><input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" role="switch" type="checkbox"/><label for="toctree-checkbox-12"><div class="visually-hidden">Toggle navigation of Utils (qiskit_qec.utils)</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.utils.indexer.html">qiskit_qec.utils.indexer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.utils.pauli_rep.html">qiskit_qec.utils.pauli_rep</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.utils.visualizations.html">qiskit_qec.utils.visualizations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.utils.get_counts_via_stim.html">qiskit_qec.utils.get_counts_via_stim</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.utils.get_stim_circuits.html">qiskit_qec.utils.get_stim_circuits</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.utils.noisify_circuit.html">qiskit_qec.utils.noisify_circuit</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.utils.DecodingGraphNode.html">DecodingGraphNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../stubs/qiskit_qec.utils.DecodingGraphEdge.html">DecodingGraphEdge</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../discussions/index.html">Discussions</a></li>
</ul>

</div></div>
      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <h1>Source code for qiskit_qec.linear.symplectic</h1><div class="highlight"><pre>
<span></span><span class="c1"># This code is part of Qiskit.</span>
<span class="c1">#</span>
<span class="c1"># (C) Copyright IBM 2017, 2020</span>
<span class="c1">#</span>
<span class="c1"># This code is licensed under the Apache License, Version 2.0. You may</span>
<span class="c1"># obtain a copy of this license in the LICENSE.txt file in the root directory</span>
<span class="c1"># of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.</span>
<span class="c1">#</span>
<span class="c1"># Any modifications or derivative works of this code must retain this</span>
<span class="c1"># copyright notice, and modified files need to carry a notice indicating</span>
<span class="c1"># that they have been altered from the originals.</span>

<span class="sd">&quot;&quot;&quot;Symplectic functions.&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">qiskit</span><span class="w"> </span><span class="kn">import</span> <span class="n">QiskitError</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">qiskit_qec.linear</span><span class="w"> </span><span class="kn">import</span> <span class="n">matrix</span> <span class="k">as</span> <span class="n">mt</span>


<span class="c1"># pylint: disable=invalid-name</span>
<div class="viewcode-block" id="all_commute">
<a class="viewcode-back" href="../../../stubs/qiskit_qec.linear.all_commute.html#qiskit_qec.linear.all_commute">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">all_commute</span><span class="p">(</span><span class="n">matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Determines if each possible pair of different rows of the</span>
<span class="sd">    GF(2) symplectic matrix have zero symplectic product. If the rows represent</span>
<span class="sd">    Pauli operators then the this method determines if the operators</span>
<span class="sd">    defined by the matrix generate an abelian subgroup.</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix: Input GF(2) symplectic matrix</span>

<span class="sd">    Returns:</span>
<span class="sd">        True if operators mutually commute - have zero symplectic product</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; matrix = numpy.array([[1,0,0,1,0,0,1,0],</span>
<span class="sd">                                  [0,1,1,1,0,0,0,1],</span>
<span class="sd">                                  [1,1,1,0,1,0,0,0],</span>
<span class="sd">                                  [1,0,0,1,0,1,0,1]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; all_commute(matrix)</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; matrix = np.array([[1,0,0,0,0,0,0,0],</span>
<span class="sd">                               [0,1,0,0,0,0,0,0],</span>
<span class="sd">                               [0,0,1,0,0,0,0,0],</span>
<span class="sd">                               [1,0,0,0,0,0,0,1]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; all_commute(matrix)</span>
<span class="sd">        True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="n">test_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">symplectic_product</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">matrix</span><span class="p">))</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="n">test_mat</span><span class="o">.</span><span class="n">any</span><span class="p">()</span></div>



<span class="c1"># ---------------------------------------------------------------</span>


<div class="viewcode-block" id="symplectic_product">
<a class="viewcode-back" href="../../../stubs/qiskit_qec.linear.symplectic_product.html#qiskit_qec.linear.symplectic_product">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">symplectic_product</span><span class="p">(</span><span class="n">mat1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">mat2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the symplectic product of two GF(2) symplectic matrices.</span>

<span class="sd">    Let math:&#39;A&#39;, math:&#39;B&#39; be two GF(2) symplectic matrices of width math:&#39;2m&#39;,</span>
<span class="sd">    then the symplectic product is defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        (A,B) = A \cdot \Lambda_n \cdot B^T.</span>

<span class="sd">    Args:</span>
<span class="sd">        mat1, mat2: Input GF(2) symplectic matrixes</span>

<span class="sd">    Returns:</span>
<span class="sd">        Symplectic product of mat1 and mat2</span>

<span class="sd">    Raises:</span>
<span class="sd">        QiskitError: Input matrices/vectors must be GF(2) symplectic matrices/vectors</span>
<span class="sd">        QiskitError: Input matrices must have the same number of dimensions</span>
<span class="sd">        QiskitError: Input matrices must be 1 or 2 dimensional</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; mat1 = numpy.array([[1,0,1,1],[0,1,1,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; mat2 = numpy.array([[0,1,1,1],[0,0,1,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; p = symplectic_product(mat1, mat2)</span>
<span class="sd">        &gt;&gt;&gt; p.astype(int)</span>
<span class="sd">        array([[0, 1], [1, 0]]</span>

<span class="sd">    See Also:</span>
<span class="sd">    _symplectic_product_vv, _symplectic_product_dense</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mat1_np_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mat1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
    <span class="n">mat2_np_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mat2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_symplectic_form</span><span class="p">(</span><span class="n">mat1</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">is_symplectic_form</span><span class="p">(</span><span class="n">mat2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;Input matrices/vectors must be GF(2) symplectic matrices/vectors&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">mat1_np_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">mat2_np_array</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Input matrices must have the </span><span class="se">\</span>
<span class="s2">            same dimensions: </span><span class="si">{</span><span class="n">mat1_np_array</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2"> is </span><span class="se">\</span>
<span class="s2">            not equal to </span><span class="si">{</span><span class="n">mat2_np_array</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">mat1_np_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mat1_np_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat2_np_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Input vectors must have the same </span><span class="se">\</span>
<span class="s2">            dimensions: </span><span class="si">{</span><span class="n">mat1_np_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> not equal </span><span class="se">\</span>
<span class="s2">            to </span><span class="si">{</span><span class="n">mat2_np_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">mat1_np_array</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_symplectic_product_vv_boolean</span><span class="p">(</span>
                <span class="n">mat1_np_array</span><span class="p">,</span> <span class="n">mat2_np_array</span><span class="p">,</span> <span class="n">mat1_np_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">_symplectic_product_vv</span><span class="p">(</span><span class="n">mat1_np_array</span><span class="p">,</span> <span class="n">mat2_np_array</span><span class="p">,</span> <span class="n">mat1_np_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">mat1_np_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_symplectic_product_dense</span><span class="p">(</span><span class="n">mat1_np_array</span><span class="p">,</span> <span class="n">mat2_np_array</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Input matrices must be 1 or 2 dimensional:</span><span class="se">\</span>
<span class="s2">            </span><span class="si">{</span><span class="n">mat1_np_array</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">mat2_np_array</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_symplectic_product_vv</span><span class="p">(</span><span class="n">vec1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">vec2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Finds the sympletic product or two GF(2) symplectic vectors of</span>
<span class="sd">    length 2n: vec1 . Lambda . vec2^T where</span>

<span class="sd">    lambda = [0 I]</span>
<span class="sd">             [I 0]</span>

<span class="sd">    Warning: This method requires integer components. Python bool and nump bool_</span>
<span class="sd">    type will give incorrect results. Use _symplectic_product_vv_boolean  or the</span>
<span class="sd">    more general symplectic_product</span>

<span class="sd">    Args:</span>
<span class="sd">        vec1, vec2: Input GF(2) symplectic vectors</span>
<span class="sd">        n: Input size, half of the symplectic vector length</span>

<span class="sd">    Returns:</span>
<span class="sd">        Symplectic product of vec1 and vec2</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; a = np.array([1,0,0,0,1,1,1,0,1,0])</span>
<span class="sd">        &gt;&gt;&gt; b = np.array([1,1,1,1,0,0,1,0,1,1])</span>
<span class="sd">        &gt;&gt;&gt; _symplectic_product_vv(a, b, 5)</span>
<span class="sd">        0</span>

<span class="sd">    See Also:</span>
<span class="sd">    symplectic_product, _symplectic_product_dense</span>

<span class="sd">    Notes:</span>
<span class="sd">    If changing the method please make sure that the new method</span>
<span class="sd">    is faster. Note that this method is faster if the vectors are</span>
<span class="sd">    numpy arrays with dtype=int8</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">vec1</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="nb">bool</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="n">vec1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">vec2</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">vec1</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">vec2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">r</span> <span class="o">%</span> <span class="mi">2</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_symplectic_product_vv_boolean</span><span class="p">(</span><span class="n">vec1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">vec2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Finds the sympletic product or two GF(2) (boolean types) symplectic vectors of</span>
<span class="sd">    length 2n: vec1 . Lambda . vec2^T where</span>

<span class="sd">    lambda = [0 I]</span>
<span class="sd">             [I 0]</span>

<span class="sd">    Warning: This method requires boolean components.</span>

<span class="sd">    Args:</span>
<span class="sd">        vec1, vec2: Input GF(2) symplectic vectors</span>
<span class="sd">        n: Input size, half of the symplectic vector length</span>

<span class="sd">    Returns:</span>
<span class="sd">        out: Symplectic product of vec1 and vec2</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; a = np.array([1,0,0,0,1,1,1,0,1,0], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; b = numpy.array([1,1,1,1,0,0,1,0,1,1], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; _symplectic_product_vv_boolean(a, b, 5)</span>
<span class="sd">        0</span>

<span class="sd">    See Also:</span>
<span class="sd">    symplectic_product, _symplectic_product_dense, _symplectic_product_vv</span>

<span class="sd">    Notes:</span>
<span class="sd">    If changing the method please make sure that the new method</span>
<span class="sd">    is faster. Note that this method is faster if the vectors are</span>
<span class="sd">    numpy arrays with dtype=int8</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">vec1</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span>
    <span class="n">r</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">^=</span> <span class="n">vec1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">vec2</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">vec1</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">vec2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_symplectic_product_dense</span><span class="p">(</span><span class="n">mat1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">mat2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the symplectic product of two GF(2) symplectic matrices.</span>

<span class="sd">    Let math:&#39;A&#39;, math:&#39;B&#39; be two GF(2) (as integer not boolean) symplectic matrices of width math:&#39;2m&#39;,</span>
<span class="sd">    then the symplectic product is defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        (A,B) = A \cdot \Lambda_n \cdot B^T.</span>

<span class="sd">    Args:</span>
<span class="sd">        mat1, mat2: Input GF(2) symplectic matrixes</span>

<span class="sd">    Returns:</span>
<span class="sd">        Symplectic product of mat1 and mat2</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; mat1 = numpy.array([[1,0,1,1],[0,1,1,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; mat2 = numpy.array([[0,1,1,1],[0,0,1,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; p = _symplectic_product_dense(mat1, mat2)</span>
<span class="sd">        &gt;&gt;&gt; p.astype(int)</span>
<span class="sd">        array([[0, 1], [1, 0]]</span>

<span class="sd">    See Also:</span>
<span class="sd">    _symplectic_product_vv, symplectic_product</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">mat1</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="nb">bool</span>
    <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hsplit</span><span class="p">(</span><span class="n">mat1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># pylint: disable=unbalanced-tuple-unpacking</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">m2</span><span class="p">,</span> <span class="n">m1</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mat2</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span> <span class="o">%</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span>


<span class="c1"># ---------------------------------------------------------------</span>


<div class="viewcode-block" id="make_commute_hyper">
<a class="viewcode-back" href="../../../stubs/qiskit_qec.linear.make_commute_hyper.html#qiskit_qec.linear.make_commute_hyper">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">make_commute_hyper</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">arange</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">xrange</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">zrange</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Makes an element(s) commute with hyperbolic pair(s)</span>

<span class="sd">    Let a = [a_0,...,a_(k-1)] where a_i are GF(2) symplectic vectors. Let</span>
<span class="sd">    x = [x_0,...,x_(l-1)] and z =[z_0,...,z_(l-1)] where x_i and z_i are</span>
<span class="sd">    GF(2) symplectic vectors such that (x_i,z_i) are hyerbolic pairs from</span>
<span class="sd">    the hyperbolic a basis &lt;x_0,...,x_(l-1),z_0,...,x_(l-1)&gt;. It is assumed</span>
<span class="sd">    that {a_0,...,a_(k-1),x_0,...,x_(l-1),z_0,...,x_(l-1)} is an independent</span>
<span class="sd">    set of symplectic vectors.</span>

<span class="sd">    This method returns a set of vectors b = [b_0,...,b_(k-1)] such that</span>

<span class="sd">    1) b_0, ..., b_(k-1) each have zero symplectic product with each of the</span>
<span class="sd">    hyperbolic vectors x_0,...,x_(l-1),z_0,...,x_(l-1)</span>
<span class="sd">    2) span(b_i, x_j,z_j)  = span(a_i, x_j,z_j)</span>
<span class="sd">    for i=0,..,k-1 and j=0,...,l-1</span>

<span class="sd">    If the symplectic vectors are considered as Pauli operators then the</span>
<span class="sd">    method returns a set of operators [op_(b_0),...,op_(b_(k-1))] such that</span>

<span class="sd">    1) op_(b_0), ..., op_(b_(k-1)) each commute with the each of the</span>
<span class="sd">    hyperbolic operators op_(x_0),...,op_(x_(l-1)),op_(z_0),...,op_(x_(l-1))</span>
<span class="sd">    2) &lt;op_(b_i), op_(x_j),op_(z_j)&gt; = &lt;op_(a_i), op_(x_j),op_(z_j)&gt;</span>
<span class="sd">    for each i=0,...,k-1 and j=0,...,l-1</span>

<span class="sd">    Args:</span>
<span class="sd">        a: Input GF(2) symplectic vectors</span>
<span class="sd">        x: GF(2) hyperbolic pair vector</span>
<span class="sd">        z: GF(2) hyperbolic pair vector</span>
<span class="sd">        arange (optional): range of indices from a to make commute. Defaults to None.</span>
<span class="sd">        xrange (optional): range of indices from x to use. Defaults to None.</span>
<span class="sd">        zrange (optional): range of indices from z to use. Defaults to None.</span>

<span class="sd">    Raises:</span>
<span class="sd">        QiskitError: Input matrices/vectors must bf GF(2) symplectic matrices/vectors</span>
<span class="sd">        QiskitError: Input range is not iterable&quot;)</span>
<span class="sd">        QiskitError: Input matrices/vectors must have the same number of columns/length</span>

<span class="sd">    Returns:</span>
<span class="sd">        GF(2) symplectic vectors that commute with the given hyperbolic pairs</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; a = numpy.array([1,1,1,0,0,0],dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; x = numpy.array([0,0,1,0,0,0],dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; z = numpy.array([0,0,0,0,0,1],dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; a = make_commute_hyper(a, x, z)</span>
<span class="sd">        &gt;&gt;&gt; a.astype(int)</span>
<span class="sd">        array([1, 1, 0, 0, 0, 0])</span>

<span class="sd">        &gt;&gt;&gt; a = numpy.array([1,1,1,0,0,0,0,0], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; x = numpy.array([[0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; z = numpy.array([[0,0,0,0,0,1,0,0],[0,0,0,0,0,0,1,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; xrange = [0,1]</span>
<span class="sd">        &gt;&gt;&gt; zrange = [0,1]</span>
<span class="sd">        &gt;&gt;&gt; a = make_commute_hyper(a, x, z, xrange = xrange, zrange=zrange)</span>
<span class="sd">        &gt;&gt;&gt; a.astype(int)</span>
<span class="sd">        array([1, 0, 0, 0, 0, 0, 0, 0])</span>

<span class="sd">        &gt;&gt;&gt; a = numpy.array([[1,1,1,0,0,0,0,0],[0,1,1,0,0,0,0,0]], dtype=numpy.bool_) # X1X2X3, X2X3</span>
<span class="sd">        &gt;&gt;&gt; x = numpy.array([0,1,0,0,0,0,0,0], dtype=numpy.bool_) # X2</span>
<span class="sd">        &gt;&gt;&gt; z = numpy.array([0,0,0,0,0,1,0,0], dtype=numpy.bool_) # Z2</span>
<span class="sd">        &gt;&gt;&gt; arange = [0,1]</span>
<span class="sd">        &gt;&gt;&gt; a = make_commute_hyper(a, x, z, arange)</span>
<span class="sd">        &gt;&gt;&gt; a.astype(int)</span>
<span class="sd">        array([[1, 0, 1, 0, 0, 0, 0, 0],</span>
<span class="sd">               [0, 0, 1, 0, 0, 0, 0, 0]])</span>

<span class="sd">        &gt;&gt;&gt; a = numpy.array([[1,1,1,0,0,0,0,0],[0,1,1,1,0,0,0,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; x = numpy.array([[0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; z = numpy.array([[0,0,0,0,0,1,0,0], [0,0,0,0,0,0,1,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; arange = [0,1]</span>
<span class="sd">        &gt;&gt;&gt; a = make_commute_hyper(a, x, z, arange)</span>
<span class="sd">        &gt;&gt;&gt; a.astype(int)</span>
<span class="sd">        array([[1, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">               [0, 0, 0, 1, 0, 0, 0, 0]])</span>

<span class="sd">    See Also:</span>
<span class="sd">    _make_commute_hyper</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">is_symplectic_form</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_symplectic_form</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_symplectic_form</span><span class="p">(</span><span class="n">z</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;Input matrices/vectors must be GF(2) symplectic matrices/vectors&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">make_list</span><span class="p">(</span><span class="n">srange</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">srange</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">srange</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">srange</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">terror</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input range </span><span class="si">{</span><span class="n">srange</span><span class="si">}</span><span class="s2"> is not iterable&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">terror</span>

        <span class="k">return</span> <span class="n">srange</span>

    <span class="n">arange</span> <span class="o">=</span> <span class="n">make_list</span><span class="p">(</span><span class="n">arange</span><span class="p">)</span>
    <span class="n">xrange</span> <span class="o">=</span> <span class="n">make_list</span><span class="p">(</span><span class="n">xrange</span><span class="p">)</span>
    <span class="n">zrange</span> <span class="o">=</span> <span class="n">make_list</span><span class="p">(</span><span class="n">zrange</span><span class="p">)</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="c1"># if &#39;a&#39; is a vector then return result as a vector otherwise return as a matrix</span>
    <span class="n">squeeze</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;Input matrices/vectors must have the same number of columns/length&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_make_commute_hyper</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">arange</span><span class="p">,</span> <span class="n">xrange</span><span class="p">,</span> <span class="n">zrange</span><span class="p">,</span> <span class="n">squeeze</span><span class="p">)</span></div>



<span class="c1"># ---------------------------------------------------------------</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_make_commute_hyper</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">arange</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">xrange</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">zrange</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">squeeze</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Makes an element(s) commute with hyperbolic pair(s)</span>

<span class="sd">    Let a = [a_0,...,a_(k-1)] where a_i are GF(2) symplectic vectors. Let</span>
<span class="sd">    x = [x_0,...,x_(l-1)] and z =[z_0,...,z_(l-1)] where x_i and z_i are</span>
<span class="sd">    GF(2) symplectic vectors such that (x_i,z_i) are hyerbolic pairs from</span>
<span class="sd">    the hyperbolic a basis &lt;x_0,...,x_(l-1),z_0,...,x_(l-1)&gt;. It is assumed</span>
<span class="sd">    that {a_0,...,a_(k-1),x_0,...,x_(l-1),z_0,...,x_(l-1)} is an independent</span>
<span class="sd">    set of symplectic vectors.</span>

<span class="sd">    This method returns a set of vectors b = [b_0,...,b_(k-1)] such that</span>

<span class="sd">    1) b_0, ..., b_(k-1) each have zero symplectic product with each of the</span>
<span class="sd">    hyperbolic vectors x_0,...,x_(l-1),z_0,...,x_(l-1)</span>
<span class="sd">    2) span(b_i, x_j,z_j)  = span(a_i, x_j,z_j)</span>
<span class="sd">    for i=0,..,k-1 and j=0,...,l-1</span>

<span class="sd">    If the symplectic vectors are considered as Pauli operators then the</span>
<span class="sd">    method returns a set of operators [op_(b_0),...,op_(b_(k-1))] such that</span>

<span class="sd">    1) op_(b_0), ..., op_(b_(k-1)) each commute with the each of the</span>
<span class="sd">    hyperbolic operators op_(x_0),...,op_(x_(l-1)),op_(z_0),...,op_(x_(l-1))</span>
<span class="sd">    2) &lt;op_(b_i), op_(x_j),op_(z_j)&gt; = &lt;op_(a_i), op_(x_j),op_(z_j)&gt;</span>
<span class="sd">    for each i=0,...,k-1 and j=0,...,l-1</span>

<span class="sd">    Args:</span>
<span class="sd">        a: Input GF(2) symplectic vectors</span>
<span class="sd">        x,z: GF(2) hyperbolic pair vectors</span>
<span class="sd">        arange (optional): range of indices from a to make commute. Defaults to None.</span>
<span class="sd">        xrange (optional): range of indices from x to use. Defaults to None.</span>
<span class="sd">        zrange (optional): range of indices from z to use. Defaults to None.</span>
<span class="sd">        squeeze (optional): squeeze = True will return a vector if a vector results</span>

<span class="sd">    Returns:</span>
<span class="sd">        GF(2) symplectic vectors that commute with the given hyperbolic pairs</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; a = numpy.array([[1,1,1,0,0,0]],dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; x = numpy.array([[0,0,1,0,0,0]],dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; z = numpy.array([[0,0,0,0,0,1]],dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; a = _make_commute_hyper(a, x, z, squeeze=True)</span>
<span class="sd">        &gt;&gt;&gt; a.astype(int)</span>
<span class="sd">        array([1, 1, 0, 0, 0, 0])</span>

<span class="sd">        &gt;&gt;&gt; a = numpy.array([[1,1,1,0,0,0,0,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; x = numpy.array([[0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; z = numpy.array([[0,0,0,0,0,1,0,0],[0,0,0,0,0,0,1,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; xrange = [0,1]</span>
<span class="sd">        &gt;&gt;&gt; zrange = [0,1]</span>
<span class="sd">        &gt;&gt;&gt; a = _make_commute_hyper(a, x, z, xrange = xrange, zrange=zrange, squeeze=False)</span>
<span class="sd">        &gt;&gt;&gt; a.astype(int)</span>
<span class="sd">        array([[1, 0, 0, 0, 0, 0, 0, 0]])</span>

<span class="sd">        &gt;&gt;&gt; a = numpy.array([[1,1,1,0,0,0,0,0],[0,1,1,0,0,0,0,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; x = numpy.array([[0,1,0,0,0,0,0,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; z = numpy.array([[0,0,0,0,0,1,0,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; arange = [0,1]</span>
<span class="sd">        &gt;&gt;&gt; a = _make_commute_hyper(a, x, z, arange)</span>
<span class="sd">        &gt;&gt;&gt; a.astype(int)</span>
<span class="sd">        array([[1, 0, 1, 0, 0, 0, 0, 0],</span>
<span class="sd">               [0, 0, 1, 0, 0, 0, 0, 0]])</span>

<span class="sd">        &gt;&gt;&gt; a = numpy.array([[1,1,1,0,0,0,0,0],[0,1,1,1,0,0,0,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; x = numpy.array([[0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; z = numpy.array([[0,0,0,0,0,1,0,0],[0,0,0,0,0,0,1,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; arange = [0,1]</span>
<span class="sd">        &gt;&gt;&gt; a = _make_commute_hyper(a, x, z, arange)</span>
<span class="sd">        &gt;&gt;&gt; a.astype(int)</span>
<span class="sd">        array([[1, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">               [0, 0, 0, 1, 0, 0, 0, 0]])</span>

<span class="sd">    See Also:</span>
<span class="sd">    make_commute_hyper</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Assuming that a, x, y are all 2d numpy arrays</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">arange</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arange</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">xrange</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">xrange</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">zrange</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">zrange</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xrange</span><span class="p">,</span> <span class="n">zrange</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">arange</span><span class="p">:</span>
            <span class="c1"># a[k] = _commute_with_pair(a[k], x[i], z[j])</span>
            <span class="n">num_qubits</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">_symplectic_product_vv</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">num_qubits</span><span class="p">):</span>
                <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">^</span> <span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">_symplectic_product_vv</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">num_qubits</span><span class="p">):</span>
                <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">^</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">squeeze</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>


<span class="c1"># ---------------------------------------------------------------</span>


<div class="viewcode-block" id="locate_hyper_partner">
<a class="viewcode-back" href="../../../stubs/qiskit_qec.linear.locate_hyper_partner.html#qiskit_qec.linear.locate_hyper_partner">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">locate_hyper_partner</span><span class="p">(</span>
    <span class="n">matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">vector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Locate a hyperbolic/noncommutative parter</span>

<span class="sd">    Let [m_0,...,m_(k-1)] be the input search matrix and v be the input vector.</span>
<span class="sd">    This method search through the vectors m_i to locate a (hyperbolic) vector that has</span>
<span class="sd">    a symplectic product with v of 1. If a hyperbolic partner &#39;av&#39; is found then it</span>
<span class="sd">    and its index in the search matrix is turned as a tuple (av, index). If no such</span>
<span class="sd">    vector exists then None value is returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix: GF(2) symplectic matrix (for search)</span>
<span class="sd">        vector: GF(2) symplectic vector to find a hyperbolic pair for</span>

<span class="sd">    Raises:</span>
<span class="sd">        QiskitError: Input matrix must be a GF(2) symplectic matrix</span>
<span class="sd">            and input vector must be a GF(2) symplectic vector</span>
<span class="sd">        QiskitError: Input {matrix} must be a 2 dimensional array</span>
<span class="sd">        QiskitError: Input {vector} must be a 1 dimensional array</span>
<span class="sd">        QiskitError: Input matrix and vector must have the same number</span>
<span class="sd">            of columns/length</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple of the found hyperbolic partner (av) and its index in the</span>
<span class="sd">            search matrix. &#39;None&#39; if no hyperbolic partner is found.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; matrix = numpy.array([[1,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; vector = numpy.array([0,0,0,0,0,1,0,0], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; av, index = locate_hyper_partner(matrix, vector)</span>
<span class="sd">        &gt;&gt;&gt; av.astype(int)</span>
<span class="sd">        array([0, 1, 1, 0, 0, 0, 0, 0])</span>
<span class="sd">        &gt;&gt;&gt; index</span>
<span class="sd">        1</span>

<span class="sd">    See Also:</span>
<span class="sd">    _locate_hyper_partner, build_hyper_partner, _build_hyper_partner</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">is_symplectic_form</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_symplectic_vector_form</span><span class="p">(</span><span class="n">vector</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Input </span><span class="si">{</span><span class="n">matrix</span><span class="si">}</span><span class="s2"> must be a GF(2) symplectic matrix</span><span class="se">\</span>
<span class="s2">            and input </span><span class="si">{</span><span class="n">vector</span><span class="si">}</span><span class="s2"> must be a GF(2) symplectic vector&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">matrix</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input </span><span class="si">{</span><span class="n">matrix</span><span class="si">}</span><span class="s2"> must be a 2 dimensional array&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">vector</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input </span><span class="si">{</span><span class="n">vector</span><span class="si">}</span><span class="s2"> must be a 1 dimensional array&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">vector</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Input matrix and vector must have the same number </span><span class="se">\</span>
<span class="s2">            of columns/length </span><span class="si">{</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">!=</span><span class="si">{</span><span class="n">vector</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">_locate_hyper_partner</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">vector</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_locate_hyper_partner</span><span class="p">(</span><span class="n">matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">vector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Locate a hyperbolic/noncommutative parter</span>

<span class="sd">    Let [m_0,...,m_(k-1)] be the input search matrix and v be the input vector.</span>
<span class="sd">    This method search through the vectors m_i to locate a (hyperbolic) vector that has</span>
<span class="sd">    a symplectic product with v of 1. If a hyperbolic partner &#39;av&#39; is found then it</span>
<span class="sd">    and its index in the search matrix is turned as a tuple (av, index). If no such</span>
<span class="sd">    vector exists then None value is returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix: GF(2) symplectic matrix (for search)</span>
<span class="sd">        vector: GF(2) symplectic vector to find a hyperbolic pair for</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple of the found hyperbolic partner (av) and its index in the</span>
<span class="sd">            search matrix. &#39;None&#39; if no hyperbolic partner is found.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; matrix = numpy.array([[1,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; vector = numpy.array([0,0,0,0,0,1,0,0], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; av, index = _locate_hyper_partner(matrix, vector)</span>
<span class="sd">        &gt;&gt;&gt; av.astype(int)</span>
<span class="sd">        array([0, 1, 1, 0, 0, 0, 0, 0])</span>
<span class="sd">        &gt;&gt;&gt; index</span>
<span class="sd">        1</span>

<span class="sd">    See Also:</span>
<span class="sd">    locate_hyper_partner, build_hyper_partner, _build_hyper_partner</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">_symplectic_product_vv</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">vector</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">index</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="c1"># ---------------------------------------------------------------</span>


<div class="viewcode-block" id="build_hyper_partner">
<a class="viewcode-back" href="../../../stubs/qiskit_qec.linear.build_hyper_partner.html#qiskit_qec.linear.build_hyper_partner">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">build_hyper_partner</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Builds an independent hyperbolic partner for the input vector indexed</span>

<span class="sd">    Let the input matrix be [m_0,...,m_(k-1)] and v = m_index. It is assumed</span>
<span class="sd">    that the vectors m_0,...,m_(k-1) have a zero pairwise</span>
<span class="sd">    symplectic product (i.e. represent a set of Pauli operators that pairwise</span>
<span class="sd">    commmute). This method will find a GF(2) symplectic vector that</span>
<span class="sd">    has zero symplectic product with each m_i != v and a symplectic product of 1</span>
<span class="sd">    with the vector v. If the vectors represent Pauli operators then this</span>
<span class="sd">    method will find a Pauli operator that commute with the operators</span>
<span class="sd">    represented by the vectors m_i != v and that anticommutes with the Pauli</span>
<span class="sd">    operator that is represented by v.</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix (np.array, SimplecticMatrix): GF(2) symplectic matrix representing a set of independent</span>
<span class="sd">            commuting generators</span>
<span class="sd">        index: index of generator to build a hyperbolic partner for</span>

<span class="sd">    Raises:</span>
<span class="sd">        QiskitError: Input matrix must be a GF(2) symplectic matrix</span>
<span class="sd">        QiskitError: Input matrix must represent a set of commuting operators</span>
<span class="sd">        QiskitError: Input matrix does not represent a set of independent</span>
<span class="sd">            operators, it does not have have full rank</span>
<span class="sd">        QiskitError: Input index out or range</span>

<span class="sd">    Returns:</span>
<span class="sd">        a hyperbolic partner for the given vector wrt the set of commuting</span>
<span class="sd">            generators</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; matrix = numpy.array(</span>
<span class="sd">            [[1,0,0,0,0,0,0,0],</span>
<span class="sd">             [0,1,0,0,0,0,0,0],</span>
<span class="sd">             [0,0,1,0,0,0,0,0],</span>
<span class="sd">             [0,0,0,1,0,0,0,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; av = build_hyper_partner(matrix, 0)</span>
<span class="sd">        &gt;&gt;&gt; av.astype(int)</span>
<span class="sd">        array([0, 0, 0, 0, 1, 0, 0, 0])</span>

<span class="sd">    See Also:</span>
<span class="sd">    _build_hyper_partner, locate_hyper_partner, _locate_hyper_partner</span>

<span class="sd">    Notes: This method is the implementation of Proposition 10.4 from Nielsen</span>
<span class="sd">    and Chuang&#39;s Quantum Computation and Quantum Information</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_symplectic_form</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input </span><span class="si">{</span><span class="n">matrix</span><span class="si">}</span><span class="s2"> must be a GF(2) symplectic matrix&quot;</span><span class="p">)</span>

    <span class="c1"># matrix -&gt; all associated operators must commute</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">all_commute</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;Input matrix must represent a set of commuting operators&quot;</span><span class="p">)</span>

    <span class="n">rank_</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rank_</span> <span class="o">!=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Input matrix does not represent a set of independent </span><span class="se">\</span>
<span class="s2">            operators, it does not have have full rank: </span><span class="si">{</span><span class="n">rank_</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input index out or range: </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">&gt;=</span><span class="si">{</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_build_hyper_partner</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_build_hyper_partner</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Builds an independent hyperbolic partner for the input vector indexed</span>

<span class="sd">    Let the input matrix be [m_0,...,m_(k-1)] and v = m_index. It is assumed</span>
<span class="sd">    that the vectors m_0,...,m_(k-1) have a zero pairwise</span>
<span class="sd">    symplectic product (i.e. represent a set of Pauli operators that pairwise</span>
<span class="sd">    commmute). This method will find a GF(2) symplectic vector that</span>
<span class="sd">    has zero symplectic product with each m_i != v and a symplectic product of 1</span>
<span class="sd">    with the vector v. If the vectors represent Pauli operators then this</span>
<span class="sd">    method will find a Pauli operator that commute with the operators</span>
<span class="sd">    represented by the vectors m_i != v and that anticommutes with the Pauli</span>
<span class="sd">    operator that is represented by v.</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix: GF(2) symplectic matrix representing a set of independent</span>
<span class="sd">            commuting generators</span>
<span class="sd">        index: index of generator to build a hyperbolic partner for</span>

<span class="sd">    Returns:</span>
<span class="sd">        a hyperbolic partner for the given vector wrt the set of commuting</span>
<span class="sd">            generators</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; matrix = numpy.array(</span>
<span class="sd">            [[1,0,0,0,0,0,0,0],</span>
<span class="sd">             [0,1,0,0,0,0,0,0],</span>
<span class="sd">             [0,0,1,0,0,0,0,0],</span>
<span class="sd">             [0,0,0,1,0,0,0,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; av = _build_hyper_partner(matrix, 0)</span>
<span class="sd">        &gt;&gt;&gt; av.astype(int)</span>
<span class="sd">        array([0, 0, 0, 0, 1, 0, 0, 0])</span>

<span class="sd">    See Also:</span>
<span class="sd">    build_hyper_partner, locate_hyper_partner, _locate_hyper_partner</span>

<span class="sd">    Notes: This method is the implementation of Proposition 10.4 from Nielsen</span>
<span class="sd">    and Chuang&#39;s Quantum Computation and Quantum Information</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nrows</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ncols</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">_lambda</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">create_lambda_matrix</span><span class="p">(</span><span class="n">ncols</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">slambda</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">_lambda</span><span class="p">)</span>

    <span class="n">heads</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">transform_mat</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">_rref_complete</span><span class="p">(</span><span class="n">slambda</span><span class="p">)</span>

    <span class="n">e_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">e_index</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">trans_e_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">transform_mat</span><span class="p">,</span> <span class="n">e_index</span><span class="p">)</span>

    <span class="n">pivot</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ncols</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncols</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">heads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans_e_index</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span>
            <span class="n">pivot</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="c1"># ---------------------------------------------------------------</span>


<div class="viewcode-block" id="symplectic_gram_schmidt">
<a class="viewcode-back" href="../../../stubs/qiskit_qec.linear.symplectic_gram_schmidt.html#qiskit_qec.linear.symplectic_gram_schmidt">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">symplectic_gram_schmidt</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Applies the sympletic Gram-Schmidt process to the input matrix</span>

<span class="sd">    Apply the symplectic GramSchmidt process to the input symplectic matrix. Resulting</span>
<span class="sd">    hyperbolic pairs are added to x and z arrays. Elements of the center will be added to the</span>
<span class="sd">    center array.</span>

<span class="sd">    Args:</span>
<span class="sd">        a: Symplectic matrix</span>
<span class="sd">        x (optional): GF(2) Symplectic matrices representing hyperbolic pairs to</span>
<span class="sd">        z (optional): GF(2) Symplectic matrices representing hyperbolic pairs to</span>
<span class="sd">        build upon. Default is None.</span>

<span class="sd">    Raises:</span>
<span class="sd">        QiskitError Input matric not a GF(2) symplectic matrix</span>
<span class="sd">        QiskitError: Input hyperbolic array x is not a GF(2) sympletic matrix</span>
<span class="sd">        QiskitError: Input hyperbolic array z is not a GF(2) sympletic matrix</span>
<span class="sd">        QiskitError: Input hyperbolic arrays have different dimensions</span>
<span class="sd">        QiskitError: Input hyperbolic matrices do not represent a hyperbolic basis</span>

<span class="sd">    Returns:</span>
<span class="sd">        Center array and hyperbolic pairs split accross x and z</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; a = numpy.array([[0,1,0,0,1,0,1,0],</span>
<span class="sd">                          [0,0,0,0,1,1,0,1],</span>
<span class="sd">                          [1,1,1,0,0,1,0,0],</span>
<span class="sd">                          [1,1,0,1,0,0,0,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; center_, x, z = symplectic_gram_schmidt(a)</span>
<span class="sd">        &gt;&gt;&gt; center_.astype(int)</span>
<span class="sd">        array([[1, 1, 1, 0, 1, 0, 0, 1],</span>
<span class="sd">               [1, 0, 0, 1, 0, 1, 1, 1]])</span>
<span class="sd">       &gt;&gt;&gt; x.astype(int)</span>
<span class="sd">       array([[0, 1, 0, 0, 1, 0, 1, 0]])</span>
<span class="sd">       &gt;&gt;&gt; z.astype(int)</span>
<span class="sd">       array([[0, 0, 0, 0, 1, 1, 0, 1]])</span>

<span class="sd">    Also See:</span>
<span class="sd">    _symplectic_gram_schmidt</span>

<span class="sd">    TODO: Add an example that shows using the optional x and z arrays</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_symplectic_matrix_form</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;Input matrix not a GF(2) symplectic matrix&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_symplectic_vector_form</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;Input hyperbolic array x is not a GF(2) sympletic matrix&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_symplectic_vector_form</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;Input hyperbolic array z is not a GF(2) sympletic matrix&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;Input hyperbolic arrays have different dimensions&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;Input hyperbolic arrays have different dimensions&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="p">[]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_hyper_form</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;Input hyperbolic matrices do not represent a hyperbolic basis&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_symplectic_gram_schmidt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_symplectic_gram_schmidt</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">z</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Applies the sympletic Gram-Schmidt process to the input matrix</span>

<span class="sd">    Apply the symplectic GramSchmidt process to the input symplectic matrix. Resulting</span>
<span class="sd">    hyperbolic pairs are added to x and z arrays. Elements of the center will we added to the</span>
<span class="sd">    center array.</span>

<span class="sd">    Args:</span>
<span class="sd">        a: Symplectic matrix</span>
<span class="sd">        x, z (optional): GF(2) Symplectic matrices representing hyperbolic pairs to</span>
<span class="sd">            build upon. Default is None.</span>

<span class="sd">    Raises:</span>
<span class="sd">        QiskitError Input matric not a GF(2) symplectic matrix</span>
<span class="sd">        QiskitError: Input hyperbolic array x is not a GF(2) sympletic matrix</span>
<span class="sd">        QiskitError: Input hyperbolic array z is not a GF(2) sympletic matrix</span>
<span class="sd">        QiskitError: Input hyperbolic arrays have different dimensions</span>

<span class="sd">    Returns:</span>
<span class="sd">        Center array and hyperbolic pairs split accross x and z</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; a = numpy.array([[0,1,0,0,1,0,1,0],</span>
<span class="sd">                          [0,0,0,0,1,1,0,1],</span>
<span class="sd">                          [1,1,1,0,0,1,0,0],</span>
<span class="sd">                          [1,1,0,1,0,0,0,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; center_, x, z = _symplectic_gram_schmidt(a, [], [])</span>
<span class="sd">        &gt;&gt;&gt; center_.astype(int)</span>
<span class="sd">        array([[1, 1, 1, 0, 1, 0, 0, 1],</span>
<span class="sd">               [1, 0, 0, 1, 0, 1, 1, 1]])</span>
<span class="sd">        &gt;&gt;&gt; x.astype(int)</span>
<span class="sd">        array([[0, 1, 0, 0, 1, 0, 1, 0]])</span>
<span class="sd">        &gt;&gt;&gt; z.astype(int)</span>
<span class="sd">        array([[0, 0, 0, 0, 1, 1, 0, 1]])</span>

<span class="sd">    Also See:</span>
<span class="sd">    _symplectic_gram_schmid</span>

<span class="sd">    TODO: Add an example that shows using the optional x and z arrays</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">a_view</span> <span class="o">=</span> <span class="n">a</span>
    <span class="n">center_</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="n">a_view</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">elem</span> <span class="o">=</span> <span class="n">a_view</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Remove elem from a_view</span>
        <span class="n">a_view</span> <span class="o">=</span> <span class="n">a_view</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">elem_p</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">_locate_hyper_partner</span><span class="p">(</span><span class="n">a_view</span><span class="p">,</span> <span class="n">elem</span><span class="p">)</span>
            <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
            <span class="n">z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem_p</span><span class="p">)</span>

            <span class="c1"># Revove elem_p from a_view</span>
            <span class="n">temp_view</span> <span class="o">=</span> <span class="n">a_view</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">temp_view</span><span class="p">[</span><span class="n">index</span><span class="p">:]</span> <span class="o">=</span> <span class="n">a_view</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
            <span class="n">a_view</span> <span class="o">=</span> <span class="n">temp_view</span>

            <span class="n">a_view</span> <span class="o">=</span> <span class="n">make_commute_hyper</span><span class="p">(</span><span class="n">a_view</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="n">elem_p</span><span class="p">)</span>
            <span class="c1"># TODO: Change the above line to use the faster version</span>
            <span class="c1"># a_view = _make_elements_commute_with_hyper_pair(</span>
            <span class="c1">#    a_view, range(a_view.shape[0]), elem, elem_p</span>
            <span class="c1"># )</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">elem</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">center_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">center_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">center_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">center_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">center_</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">center_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span>


<span class="c1"># ---------------------------------------------------------------</span>


<span class="k">def</span><span class="w"> </span><span class="nf">count_num_y</span><span class="p">(</span><span class="n">matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">scalar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the number of positions with 1&#39;s in k and n+k positions</span>
<span class="sd">    for matrices/vectors of width 2n for all k</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix: Input GF(2) symplectic matrix/vector</span>
<span class="sd">        scalar: If scalar is True and a vector is input then a scalar will</span>
<span class="sd">            be output else a vector will be output. Default is True</span>

<span class="sd">    Raises:</span>
<span class="sd">        QiskitError: Input matrix/vector not a GF(2) symplectic matrix</span>

<span class="sd">    Returns:</span>
<span class="sd">        result: number of positions with 1&#39;s in k and n+k positions</span>
<span class="sd">    for matrices/vectors of width 2n for all k.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; a = np.array([1,0,1,1], dtype=np.bool_)</span>
<span class="sd">        &gt;&gt;&gt; count_num_y(a)</span>
<span class="sd">        1</span>

<span class="sd">        &gt;&gt;&gt; a = np.array([1,0,1,1], dtype=np.bool_)</span>
<span class="sd">        &gt;&gt;&gt; count_num_y(a, scalar=False)</span>
<span class="sd">        array([1])</span>

<span class="sd">        &gt;&gt;&gt; b = np.array([[1,0,1,1],[0,0,1,1]], dtype=np.bool_)</span>
<span class="sd">        &gt;&gt;&gt; count_num_y(b)</span>
<span class="sd">        array([1,0])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_symplectic_form</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;Input matrix/vector not a GF(2) symplectic matrix&quot;</span><span class="p">)</span>
    <span class="n">num_qubits</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_count_num_y</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">num_qubits</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">scalar</span> <span class="ow">and</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_count_num_y</span><span class="p">(</span><span class="n">matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the number of positions with 1&#39;s in k and n+k positions</span>
<span class="sd">    for matrices/vectors of width 2n for all k</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix (np.ndarray): Input GF(2) symplectic matrix/vector</span>
<span class="sd">        n (int): half of the number of columns of input matrix</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: number of positions with 1&#39;s in k and n+k positions</span>
<span class="sd">    for matrices/vectors of width 2n for all k.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; a = np.array([1,0,1,1], dtype=np.bool_)</span>
<span class="sd">        &gt;&gt;&gt; _count_num_y(a)</span>
<span class="sd">        array([1])</span>

<span class="sd">        &gt;&gt;&gt; b = np.array([[1,0,1,1],[0,0,1,1]], dtype=np.bool_)</span>
<span class="sd">        &gt;&gt;&gt; count_num_y(a, scalar=False)</span>
<span class="sd">        array([1,0])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">matrix</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n</span><span class="p">],</span> <span class="n">matrix</span><span class="p">[:,</span> <span class="n">n</span><span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>


<span class="c1"># ---------------------------------------------------------------</span>


<div class="viewcode-block" id="is_symplectic_matrix_form">
<a class="viewcode-back" href="../../../stubs/qiskit_qec.linear.is_symplectic_matrix_form.html#qiskit_qec.linear.is_symplectic_matrix_form">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_symplectic_matrix_form</span><span class="p">(</span>
    <span class="n">matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Is the input matrix GF(2) symplectic</span>

<span class="sd">    Checks if the given array-like matrix is in the form of a symplectic matrix:</span>
<span class="sd">    two dimensional, even number of columns, 0/1 or boolean entries. The optional</span>
<span class="sd">    argument dtype can be given to check if entries are a specific dtype</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix: Input matrix to be checked</span>
<span class="sd">        dtype: Optional. Check if given matrix is of type dtype. Default: None</span>

<span class="sd">    Returns:</span>
<span class="sd">        True if the input matrix is GF(2) symplectic. False otherwise.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; matrix = numpy.array([[1,0,0,1,0,0,1,0],[0,1,1,1,0,0,0,1]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; is_symplectic_matrix_form(matrix)</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; matrix = numpy.array([[1,0,0,1,0,0,1],[0,1,1,1,0,0,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; is_symplectic_matrix_form(matrix)</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; matrix = numpy.array([[1,0,0,1],[0,1,1,1]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; is_symplectic_matrix_form(matrix, dtype=int)</span>
<span class="sd">        False</span>

<span class="sd">    See Also:</span>
<span class="sd">    is_symplectic_vector_form, is_symplectic_form</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">matrix</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">%</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span></div>



<div class="viewcode-block" id="is_symplectic_vector_form">
<a class="viewcode-back" href="../../../stubs/qiskit_qec.linear.is_symplectic_vector_form.html#qiskit_qec.linear.is_symplectic_vector_form">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_symplectic_vector_form</span><span class="p">(</span>
    <span class="n">vector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Is the input vector GF(2) symplectic</span>

<span class="sd">    Checks if the given array like vector is in the form of a symplectic vector:</span>
<span class="sd">    two dimensional, even number of columns, 0/1 or boolean entries. The optional</span>
<span class="sd">    argument dtype can be given to check if entries are a specific dtype</span>

<span class="sd">    Args:</span>
<span class="sd">        vector: Input vector to be checked</span>
<span class="sd">        dtype: Optional. Check if given vector is of type dtype. Default: None</span>

<span class="sd">    Returns:</span>
<span class="sd">        True if the input vector is GF(2) symplectic. False otherwise.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; vector = numpy.array([[1,0,0,1,0,0,1,0],[0,1,1,1,0,0,0,1]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; is_symplectic_vector_form(vector)</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; vector = numpy.array([[1,0,0,1,0,0,1,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; is_symplectic_vector_form(vector)</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; vector = numpy.array([[1,0,0,1,0,0,1,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; is_symplectic_vector_form(vector)</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; vector = numpy.array([1,0,0,1], dtype=numpy.int8)</span>
<span class="sd">        &gt;&gt;&gt; is_symplectic_vector_form(vector, dtype=numpy.int8)</span>
<span class="sd">        False</span>

<span class="sd">    See Also:</span>
<span class="sd">    is_symplectic_matrix_form, is_symplectic_form</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">vector</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">vector</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">vector</span> <span class="o">%</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span></div>



<div class="viewcode-block" id="is_symplectic_form">
<a class="viewcode-back" href="../../../stubs/qiskit_qec.linear.is_symplectic_form.html#qiskit_qec.linear.is_symplectic_form">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_symplectic_form</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Is the input a GF(2) symplectic matrix or vector</span>

<span class="sd">    Args:</span>
<span class="sd">        a: Input to be checked</span>
<span class="sd">        dtype (Optional): Check if given matrix/vector is of type dtype. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        True if the input matrix/vector is GF(2) symplectic. False otherwise.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; vector = numpy.array([[1,0,0,1,0,0,1,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; is_symplectic_form(vector)</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; matrix = numpy.array([[1,0,0,1,0,0,1],[0,1,1,1,0,0,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; is_symplectic_form(matrix)</span>
<span class="sd">        False</span>

<span class="sd">    See Also:</span>
<span class="sd">    is_symplectic_vector_form, is_symplectic_matrix_form</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">is_symplectic_vector_form</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">is_symplectic_matrix_form</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>



<span class="c1"># ---------------------------------------------------------------</span>


<div class="viewcode-block" id="is_center">
<a class="viewcode-back" href="../../../stubs/qiskit_qec.linear.is_center.html#qiskit_qec.linear.is_center">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_center</span><span class="p">(</span><span class="n">cntr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Does the input center matrix represent the center of the supplied matrix?</span>

<span class="sd">    Let op(cntr) = [op(c_0),op(c_1),...,op(c_(k-1))] be the Pauli operators</span>
<span class="sd">    represented by the input center_matrix. Let op(matrix) = [op(m_0),op(m_1),...,op(m_(t-1))]</span>
<span class="sd">    be the Pauli operators represented by the input matrix. This method</span>
<span class="sd">    returns True if &lt;op(cntr)&gt; = Z(&lt;op(matrix)&gt;) and False otherwise.</span>

<span class="sd">    Args:</span>
<span class="sd">        cntr (np.ndarray): Generators of center to be checked</span>
<span class="sd">        matrix (np.ndarray): Generators of full group</span>

<span class="sd">    Raises:</span>
<span class="sd">        QiskitError: Not all inputs are not GF(2) symplectic matrices/vectors</span>

<span class="sd">    Returns:</span>
<span class="sd">        True if &lt;op(cntr)&gt; = Z(&lt;op(matrix)&gt;), False otherwise</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; matrix = numpy.array(</span>
<span class="sd">            [[0,1,0,0,1,0,1,0],</span>
<span class="sd">            [0,0,0,0,1,1,0,1],</span>
<span class="sd">            [1,1,1,0,0,1,0,0],</span>
<span class="sd">            [1,1,0,1,0,0,0,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; cntr = numpy.array([[1, 1, 1, 0, 1, 0, 0, 1],</span>
<span class="sd">                                [1, 0, 0, 1, 0, 1, 1, 1]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; is_center(cntr, matrix)</span>
<span class="sd">        True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">))</span>
    <span class="n">cntr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cntr</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">is_symplectic_matrix_form</span><span class="p">(</span><span class="n">cntr</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_symplectic_matrix_form</span><span class="p">(</span><span class="n">matrix</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;Not all inputs are not GF(2) symplectic matrices&quot;</span><span class="p">)</span>
    <span class="n">cal_center</span> <span class="o">=</span> <span class="n">center</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">is_same_span</span><span class="p">(</span><span class="n">cntr</span><span class="p">,</span> <span class="n">cal_center</span><span class="p">)</span></div>



<span class="c1"># ---------------------------------------------------------------</span>


<div class="viewcode-block" id="is_same_span">
<a class="viewcode-back" href="../../../stubs/qiskit_qec.linear.is_same_span.html#qiskit_qec.linear.is_same_span">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_same_span</span><span class="p">(</span><span class="n">matrix1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">matrix2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Does span(rows of matrix1) = span(rows of matrix2)?</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix1: First set of vectors</span>
<span class="sd">        matrix2: Second set of vectors</span>

<span class="sd">    Returns:</span>
<span class="sd">        True if span(rows of matrix1) = span(rows of matrix2). False otherwise</span>

<span class="sd">    Raises:</span>
<span class="sd">        QiskitError: Inpiut matrices must by GF(2) symplectic matrices</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; matrix1 = numpy.array([[1,1,0,0],[0,0,1,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; matrix2 = numpy.array([[1,1,1,0],[0,0,1,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; is_same_span(matrix1, matrix2)</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; matrix1 = numpy.array([[1,1,0,0],[0,0,1,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; matrix2 = numpy.array([[1,1,1,0],[0,0,0,1]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; is_same_span(matrix1, matrix2)</span>
<span class="sd">        False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matrix1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix1</span><span class="p">))</span>
    <span class="n">matrix2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix2</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">is_symplectic_form</span><span class="p">(</span><span class="n">matrix1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_symplectic_form</span><span class="p">(</span><span class="n">matrix2</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;Inpiut matrices must by GF(2) symplectic matrices&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">matrix1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">matrix2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">rref_matrix1</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">rank_matrix1</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">rref_complete</span><span class="p">(</span><span class="n">matrix1</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">rref_matrix2</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">rank_matrix2</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">rref_complete</span><span class="p">(</span><span class="n">matrix2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rank_matrix1</span> <span class="o">!=</span> <span class="n">rank_matrix2</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">rref_matrix1</span> <span class="o">=</span> <span class="n">rref_matrix1</span><span class="p">[:</span><span class="n">rank_matrix1</span><span class="p">]</span>
    <span class="n">rref_matrix2</span> <span class="o">=</span> <span class="n">rref_matrix2</span><span class="p">[:</span><span class="n">rank_matrix2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">rref_matrix1</span><span class="p">,</span> <span class="n">rref_matrix2</span><span class="p">)</span></div>



<div class="viewcode-block" id="is_hyper_form">
<a class="viewcode-back" href="../../../stubs/qiskit_qec.linear.is_hyper_form.html#qiskit_qec.linear.is_hyper_form">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_hyper_form</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">z</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Do the input matrices form a hyperbolic/symplectic basis?</span>

<span class="sd">    Args:</span>
<span class="sd">        x,z: Pairs to test if they form a hyperbolic/symnplectic basis</span>

<span class="sd">    Returns:</span>
<span class="sd">        True if input matrices form a hyperbolic/symplectic basis</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; x = numpy.array([[1,0,0,0,],[0,1,0,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; z = numpy.array([[0,0,1,0,],[0,0,0,1]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; is_hyper_form(x,z)</span>
<span class="sd">        True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

    <span class="c1"># Check for empty x and z: Null comdition -&gt; True</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span>
    <span class="n">test</span> <span class="o">=</span> <span class="n">symplectic_product</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">matrix</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">_create_lambda_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span></div>



<div class="viewcode-block" id="is_stabilizer_group">
<a class="viewcode-back" href="../../../stubs/qiskit_qec.linear.is_stabilizer_group.html#qiskit_qec.linear.is_stabilizer_group">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_stabilizer_group</span><span class="p">(</span><span class="n">matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Do the rows of the input matrix represent the generators of an</span>
<span class="sd">    abelian Pauli subgroup?</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix: GF(2) symplectic matrix</span>

<span class="sd">    Raises:</span>
<span class="sd">        QiskitError: Input matrix not a GF(2) symplectic matrix</span>

<span class="sd">    Returns:</span>
<span class="sd">        True is matrix represents a Stabilizer group</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; matrix = numpy.array([[1,0,0,0,0,0],</span>
<span class="sd">                               [0,1,0,0,0,0],</span>
<span class="sd">                               [1,0,0,0,0,1]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; is_stabilizer_group(matrix)</span>
<span class="sd">        True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_symplectic_matrix_form</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;Input matrix not a GF(2) symplectic matrix&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">all_commute</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span></div>



<span class="c1"># ---------------------------------------------------------------</span>


<span class="k">def</span><span class="w"> </span><span class="nf">center</span><span class="p">(</span><span class="n">matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">preserve</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the center of the group with generators given by the symplectic matrix</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix: GF(2) symplectic matrix</span>
<span class="sd">        preserve: If True then an attempt will be made to preserve then generators form</span>

<span class="sd">    Raises:</span>
<span class="sd">        QiskitError: Input matrix is not a symplectic matrix</span>

<span class="sd">    Returns:</span>
<span class="sd">        Generators for the center, represented as a symplectic matrix,</span>
<span class="sd">            of the group with generators given by the input symplectic matrix</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; matrix = numpy.array([[1,1,0,0,1,0],</span>
<span class="sd">                               [0,0,0,1,1,0],</span>
<span class="sd">                               [0,1,0,1,0,1]], dtype=numpy.bool_)</span>
<span class="sd">       &gt;&gt;&gt; center_ = center(matrix)</span>
<span class="sd">       &gt;&gt;&gt; center_.astype(int)</span>
<span class="sd">       array([[1, 1, 0, 0, 1, 0]])</span>

<span class="sd">    See Also:</span>
<span class="sd">    _center, _center_preserve</span>

<span class="sd">    TODO: Add in example with preserve=True is useful</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_symplectic_matrix_form</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;Input matrix is not a symplectic matrix&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">preserve</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_center_preserve</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_center</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_center</span><span class="p">(</span><span class="n">matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the center of the group with generators given by the symplectic matrix</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix: GF(2) symplectic matrix</span>

<span class="sd">    Returns:</span>
<span class="sd">        Generators for the center, represented as a symplectic matrix,</span>
<span class="sd">            of the group with generators given by the input symplectic matrix</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; matrix = numpy.array([[1,1,0,0,1,0],</span>
<span class="sd">                               [0,0,0,1,1,0],</span>
<span class="sd">                               [0,1,0,1,0,1]], dtype=numpy.bool_)</span>
<span class="sd">       &gt;&gt;&gt; center_ = _center(matrix)</span>
<span class="sd">       &gt;&gt;&gt; center_.astype(int)</span>
<span class="sd">       array([[1, 1, 0, 0, 1, 0]])</span>

<span class="sd">    Notes:</span>
<span class="sd">    This method may nbot preserve any input vectors</span>

<span class="sd">    See Also:</span>
<span class="sd">    center</span>

<span class="sd">    TODO: Add in example with preserve=True is useful</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_symplectic_gram_schmidt</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[])[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_center_preserve</span><span class="p">(</span><span class="n">matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the center of the group with generators given by the symplectic matrix</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix: GF(2) symplectic matrix</span>

<span class="sd">    Returns:</span>
<span class="sd">        Generators for the center, represented as a symplectic matrix,</span>
<span class="sd">            of the group with generators given by the input symplectic matrix</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; matrix = numpy.array([[1,1,0,0,1,0],</span>
<span class="sd">                                  [0,0,0,1,1,0],</span>
<span class="sd">                                  [0,1,0,1,0,1]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; center_ = _center_preserve(matrix)</span>
<span class="sd">        &gt;&gt;&gt; center_.astype(int)</span>
<span class="sd">        array([[1, 1, 0, 0, 1, 0]])</span>

<span class="sd">    Notes:</span>
<span class="sd">    This method attempots to preserve any input vectors</span>

<span class="sd">    See Also:</span>
<span class="sd">    _center, center</span>

<span class="sd">    TODO: Add in example with preserve is actually needed</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># First move any generator that is in the center to the front of the list</span>
    <span class="n">rematrix</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">opi</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
        <span class="n">break_flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">opj</span> <span class="ow">in</span> <span class="n">matrix</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_symplectic_product_vv</span><span class="p">(</span><span class="n">opi</span><span class="p">,</span> <span class="n">opj</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">break_flag</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">break_flag</span><span class="p">:</span>
            <span class="n">rematrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">opi</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rematrix</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">opi</span><span class="p">)</span>
    <span class="c1"># Now calculate the center as normal</span>
    <span class="n">rematrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rematrix</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_center</span><span class="p">(</span><span class="n">rematrix</span><span class="p">)</span>


<span class="c1"># ---------------------------------------------------------------</span>


<span class="k">def</span><span class="w"> </span><span class="nf">basis_for_pauli_group</span><span class="p">(</span><span class="n">matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a set of generators (not necessarily independent) find</span>
<span class="sd">    a full basis using as many of the provided generators as possible.</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix: Set of generators (in GF(2) symplectic form)</span>

<span class="sd">    Raises:</span>
<span class="sd">        QiskitError: Input matrix not in a GF(2) symplectic matrix</span>

<span class="sd">    Returns:</span>
<span class="sd">        A maximal independant set</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; matrix = numpy.array([[1,1,0,0,1,0],[0,0,0,1,1,0],[0,1,0,1,0,1]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; basis = basis_for_pauli_group(matrix)</span>
<span class="sd">        &gt;&gt;&gt; basis.astype(int)</span>
<span class="sd">        array([[1, 1, 0, 0, 1, 0],</span>
<span class="sd">                [0, 0, 0, 1, 1, 0],</span>
<span class="sd">                [0, 1, 0, 1, 0, 1],</span>
<span class="sd">                [1, 0, 0, 0, 0, 0],</span>
<span class="sd">                [0, 1, 0, 0, 0, 0],</span>
<span class="sd">                [0, 0, 1, 0, 0, 0]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">matrix</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_symplectic_matrix_form</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;Input matrix not in a GF(2) symplectic matrix&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_basis_for_pauli_group</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_basis_for_pauli_group</span><span class="p">(</span><span class="n">matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a set of generators (not necessarily independent) find</span>
<span class="sd">    a full basis using as many of the provided generators as possible.</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix: Set of generators (in GF(2) symplectic form)</span>

<span class="sd">    Returns:</span>
<span class="sd">        A maximal independant set</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; matrix = numpy.array([[1,1,0,0,1,0],[0,0,0,1,1,0],[0,1,0,1,0,1]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; basis = _basis_for_pauli_group(matrix)</span>
<span class="sd">        &gt;&gt;&gt; basis.astype(int)</span>
<span class="sd">        array([[1, 1, 0, 0, 1, 0],</span>
<span class="sd">                [0, 0, 0, 1, 1, 0],</span>
<span class="sd">                [0, 1, 0, 1, 0, 1],</span>
<span class="sd">                [1, 0, 0, 0, 0, 0],</span>
<span class="sd">                [0, 1, 0, 0, 0, 0],</span>
<span class="sd">                [0, 0, 1, 0, 0, 0]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">aug_matrix</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">augment_mat</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="s2">&quot;bottom&quot;</span><span class="p">)</span>
    <span class="n">heads</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">rank</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">_rref_complete</span><span class="p">(</span><span class="n">aug_matrix</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">aug_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">ext_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
    <span class="n">posns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">heads</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">posns</span><span class="p">):</span>
        <span class="n">ext_matrix</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">aug_matrix</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ext_matrix</span>


<span class="k">def</span><span class="w"> </span><span class="nf">make_hyperbolic</span><span class="p">(</span>
    <span class="n">center_</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Makes a isotropic hyperbolic basis into an hyperbolic basis</span>

<span class="sd">    Let center, x and z (where x, z and center are represented by GF(2)</span>
<span class="sd">    symplectic matrices/vectors) be a isotropic-hyperbolic basis with</span>
<span class="sd">    2m+k total generators. This method makes/extends this basis into</span>
<span class="sd">    a hyperbolic basis for the (m+k)-th Pauli group by constructing hyperbolic</span>
<span class="sd">    partners (acenter) for each element in the center such that</span>

<span class="sd">    P_(n+k) = &lt;iI, x_new, z_new&gt;</span>

<span class="sd">    where x_new = &lt;x, center&gt;  and z_new = &lt;z, acenter&gt;</span>

<span class="sd">    Args:</span>
<span class="sd">        center_: isotropic part of basis (center)</span>
<span class="sd">        x: hyperbolic part of basis</span>
<span class="sd">        z: hyperbolic part of basis</span>

<span class="sd">    Raises:</span>
<span class="sd">        QiskitError: Input center is not center of group generated by vectors from center, x and z</span>
<span class="sd">        QiskitError: Input matrices x, z are not in hyperbolic pairs</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; center_ = numpy.array([[1, 1, 1, 0, 1, 0, 0, 1],</span>
<span class="sd">                                [1, 0, 0, 1, 0, 1, 1, 1]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; x = numpy.array([[0, 1, 0, 0, 1, 0, 1, 0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; z = numpy.array([[0, 0, 0, 0, 1, 1, 0, 1]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; center_, x, z = symplectic_gram_schmidt(a, x, z)</span>
<span class="sd">        &gt;&gt;&gt; x, z = make_hyperbolic(center_, x, z)</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        array([[0, 1, 0, 0, 1, 0, 1, 0],</span>
<span class="sd">               [1, 0, 0, 1, 0, 1, 1, 1],</span>
<span class="sd">               [1, 1, 1, 0, 1, 0, 0, 1]])</span>
<span class="sd">        &gt;&gt;&gt; z</span>
<span class="sd">        array([[0, 0, 0, 0, 1, 1, 0, 1],</span>
<span class="sd">               [0, 0, 0, 0, 1, 0, 1, 0],</span>
<span class="sd">               [0, 1, 0, 1, 0, 0, 0, 0]])</span>

<span class="sd">    See Also:</span>
<span class="sd">    _make_hyperbolic</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">center_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span>

    <span class="n">center_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">center_</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">center_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">center_</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span>

    <span class="n">center_</span> <span class="o">=</span> <span class="n">min_generating</span><span class="p">(</span><span class="n">center_</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_center</span><span class="p">(</span><span class="n">center_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">center_</span><span class="p">))):</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span>
            <span class="s2">&quot;Input center is not center of group generated by vectors from center, x and z&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_hyper_form</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;Input matrices x, z are not in hyperbolic pairs&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_make_hyperbolic</span><span class="p">(</span><span class="n">center_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_make_hyperbolic</span><span class="p">(</span>
    <span class="n">center_</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Makes a isotropic hyperbolic basis into an hyperbolic basis</span>

<span class="sd">    Let center, x and z (where x, z and center are represented by GF(2)</span>
<span class="sd">    symplectic matrices/vectors) be a isotropic-hyperbolic basis with</span>
<span class="sd">    2m+k total generators. This method makes/extends this basis into</span>
<span class="sd">    a hyperbolic basis for the (m+k)-th Pauli group by constructing hyperbolic</span>
<span class="sd">    partners (acenter) for each element in the center such that</span>

<span class="sd">    P_(n+k) = &lt;iI, x_new, z_new&gt;</span>

<span class="sd">    where x_new = &lt;x, center&gt;  and z_new = &lt;z, acenter&gt;</span>

<span class="sd">    Args:</span>
<span class="sd">        center_: isotropic part of basis (center)</span>
<span class="sd">        x, z: hyperbolic part of basis</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; center_ = numpy.array([[1, 1, 1, 0, 1, 0, 0, 1],</span>
<span class="sd">                                [1, 0, 0, 1, 0, 1, 1, 1]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; x = numpy.array([[0, 1, 0, 0, 1, 0, 1, 0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; z = numpy.array([[0, 0, 0, 0, 1, 1, 0, 1]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; center_, x, z = symplectic_gram_schmidt(a, x, z)</span>
<span class="sd">        &gt;&gt;&gt; x, z = _make_hyperbolic(center_, x, z)</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        array([[0, 1, 0, 0, 1, 0, 1, 0],</span>
<span class="sd">               [1, 0, 0, 1, 0, 1, 1, 1],</span>
<span class="sd">               [1, 1, 1, 0, 1, 0, 0, 1]])</span>
<span class="sd">        &gt;&gt;&gt; z</span>
<span class="sd">        array([[0, 0, 0, 0, 1, 1, 0, 1],</span>
<span class="sd">               [0, 0, 0, 0, 1, 0, 1, 0],</span>
<span class="sd">               [0, 1, 0, 1, 0, 0, 0, 0]])</span>

<span class="sd">    See Also:</span>
<span class="sd">    make_hyperbolic</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">center_size</span> <span class="o">=</span> <span class="n">center_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">hyper_size</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">center_size</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">spacer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">spacer</span><span class="p">))</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">z</span><span class="p">,</span> <span class="n">spacer</span><span class="p">))</span>
    <span class="n">center_</span> <span class="o">=</span> <span class="n">center_</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">while</span> <span class="n">center_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">hop</span> <span class="o">=</span> <span class="n">_build_hyper_partner</span><span class="p">(</span><span class="n">center_</span><span class="p">[:</span><span class="n">center_size</span><span class="p">],</span> <span class="n">center_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># TODO: Change the use of make_commute_hyper to _make_commute_hyper</span>
        <span class="n">hop</span> <span class="o">=</span> <span class="n">make_commute_hyper</span><span class="p">(</span><span class="n">hop</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">xrange</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">hyper_size</span><span class="p">),</span> <span class="n">zrange</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">hyper_size</span><span class="p">))</span>
        <span class="c1"># hop = _make_element_commute_with_hyper_pairs(</span>
        <span class="c1">#    hop, x, z, range(hyper_size), range(hyper_size)</span>
        <span class="c1"># )</span>

        <span class="n">center_size</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">x</span><span class="p">[</span><span class="n">hyper_size</span><span class="p">]</span> <span class="o">=</span> <span class="n">center_</span><span class="p">[</span><span class="n">center_size</span><span class="p">]</span>
        <span class="n">z</span><span class="p">[</span><span class="n">hyper_size</span><span class="p">]</span> <span class="o">=</span> <span class="n">hop</span>
        <span class="n">hyper_size</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span>


<span class="k">def</span><span class="w"> </span><span class="nf">make_isotropic_hyperbolic_form</span><span class="p">(</span>
    <span class="n">matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates a isotrophic hyperbolic basis from a set of generators</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix (np.ndarray): GF(2) symplectic matrix</span>

<span class="sd">    Returns:</span>
<span class="sd">        An isotrophic hyperbolic basis (center, x, z)</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; matrix = np.array([[0,1,0,0,1,0,1,0],</span>
<span class="sd">                               [0,0,0,0,1,1,0,1],</span>
<span class="sd">                               [1,1,1,0,0,1,0,0],</span>
<span class="sd">                               [1,1,0,1,0,0,0,0]], dtype=np.bool_)</span>
<span class="sd">        &gt;&gt;&gt; center_, x, z = make_isotropic_hyperbolic_form(matrix)</span>
<span class="sd">        &gt;&gt;&gt; center_.astype(int)</span>
<span class="sd">        array([[1, 1, 1, 0, 1, 0, 0, 1],</span>
<span class="sd">               [1, 0, 0, 1, 0, 1, 1, 1]])</span>
<span class="sd">        &gt;&gt;&gt; x.astype(int)</span>
<span class="sd">        array([[0, 1, 0, 0, 1, 0, 1, 0]])</span>
<span class="sd">        &gt;&gt;&gt; z.astype(int)</span>
<span class="sd">        array([[0, 0, 0, 0, 1, 1, 0, 1]])</span>

<span class="sd">    See Also:</span>
<span class="sd">    symplectic_gram_schmidt, _symplectic_gram_schmidt</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_symplectic_gram_schmidt</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[])</span>


<span class="k">def</span><span class="w"> </span><span class="nf">hyperbolic_basis_for_pauli_group</span><span class="p">(</span>
    <span class="n">matrix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">z</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Builds a hyperbolic basis for the associated Pauli group</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix (Optional): Input GF(2) symplectic matrix</span>
<span class="sd">        x: (Optional): Input GF(2) hyperbolic pairs</span>
<span class="sd">        z (Optional): Input GF(2) hyperbolic pairs</span>
<span class="sd">        n: Size of standard Pauli group basis to create (if matrix,x,z are None)</span>

<span class="sd">    Raises:</span>
<span class="sd">        QiskitError: x and z must be both be None or both be array like</span>
<span class="sd">        QiskitError: x not a GF(2) symplectic matrix</span>
<span class="sd">        QiskitError: z not a symplectic matrix</span>
<span class="sd">        QiskitError: matrix not a GF(2) symplectic matrix</span>
<span class="sd">        QiskitError: When providing an input hyperbolic set the input matrix</span>
<span class="sd">            must be the center of the full set of generators</span>
<span class="sd">        QiskitError: If matrix, x and z are None then n must be provided</span>

<span class="sd">    Returns:</span>
<span class="sd">        Hyperbolic basis for the associated Pauli group (new_x, new_z)</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; matrix = numpy.array([[0,1,0,0,1,0,1,0],</span>
<span class="sd">                               [0,0,0,0,1,1,0,1],</span>
<span class="sd">                               [1,1,1,0,0,1,0,0],</span>
<span class="sd">                               [1,1,0,1,0,0,0,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; center_, x, z = make_isotropic_hyperbolic_form(matrix)</span>
<span class="sd">        &gt;&gt;&gt; nx, nz = sysp.hyperbolic_basis_for_pauli_group(center_, x, z)</span>
<span class="sd">        &gt;&gt;&gt; nx.astype(int)</span>
<span class="sd">        array([[0, 1, 0, 0, 1, 0, 1, 0],</span>
<span class="sd">               [1, 0, 0, 1, 0, 1, 1, 1],</span>
<span class="sd">               [1, 1, 1, 0, 1, 0, 0, 1],</span>
<span class="sd">               [1, 0, 1, 1, 0, 0, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; nz.astype(int)</span>
<span class="sd">        array([[0, 0, 0, 0, 1, 1, 0, 1],</span>
<span class="sd">               [0, 0, 0, 0, 1, 0, 1, 0],</span>
<span class="sd">               [0, 1, 0, 1, 0, 0, 0, 0],</span>
<span class="sd">               [0, 1, 0, 1, 0, 0, 1, 0]])</span>

<span class="sd">        &gt;&gt;&gt; matrix = numpy.array([[0,1,0,0,1,0,1,0],</span>
<span class="sd">                               [0,0,0,0,1,1,0,1],</span>
<span class="sd">                               [1,1,1,0,0,1,0,0],</span>
<span class="sd">                               [1,1,0,1,0,0,0,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; nx, nz = hyperbolic_basis_for_pauli_group(matrix)</span>
<span class="sd">        array([[0, 1, 0, 0, 1, 0, 1, 0],</span>
<span class="sd">               [1, 0, 0, 1, 0, 1, 1, 1],</span>
<span class="sd">               [1, 1, 1, 0, 1, 0, 0, 1],</span>
<span class="sd">               [1, 0, 1, 1, 0, 0, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; nz.astype(int)</span>
<span class="sd">        array([[0, 0, 0, 0, 1, 1, 0, 1],</span>
<span class="sd">               [0, 0, 0, 0, 1, 0, 1, 0],</span>
<span class="sd">               [0, 1, 0, 1, 0, 0, 0, 0],</span>
<span class="sd">               [0, 1, 0, 1, 0, 0, 1, 0]])</span>

<span class="sd">        &gt;&gt;&gt; x = numpy.array([[0, 1, 0, 0, 1, 0, 1, 0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; z = numpy.array([[0, 0, 0, 0, 1, 1, 0, 1]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; nx, nz = hyperbolic_basis_for_pauli_group(x=x, z=z)</span>
<span class="sd">        &gt;&gt;&gt; nx.astype(int)</span>
<span class="sd">        array([[0, 1, 0, 0, 1, 0, 1, 0],</span>
<span class="sd">               [1, 1, 0, 0, 0, 1, 1, 1],</span>
<span class="sd">               [1, 1, 1, 0, 0, 0, 0, 0],</span>
<span class="sd">               [0, 1, 0, 1, 0, 0, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; nz.astype(int)</span>
<span class="sd">        array([[0, 0, 0, 0, 1, 1, 0, 1],</span>
<span class="sd">               [0, 0, 0, 0, 1, 0, 1, 0],</span>
<span class="sd">               [0, 0, 0, 0, 0, 0, 1, 0],</span>
<span class="sd">               [0, 0, 0, 0, 0, 0, 0, 1]])</span>

<span class="sd">        &gt;&gt;&gt; x, z = hyperbolic_basis_for_pauli_group(n=5)</span>
<span class="sd">        &gt;&gt;&gt; x.astype(int)</span>
<span class="sd">        array([[1, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">               [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">               [0, 0, 1, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">               [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">               [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; z.astype(int)</span>
<span class="sd">        array([[0, 0, 0, 0, 0, 1, 0, 0, 0, 0],</span>
<span class="sd">               [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],</span>
<span class="sd">               [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],</span>
<span class="sd">               [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],</span>
<span class="sd">               [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]])</span>

<span class="sd">    See Also:</span>
<span class="sd">    _hyperbolic_basis_for_pauli_group</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;x and z must be both be None or both be array like&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_symplectic_matrix_form</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2"> not a GF(2) symplectic matrix&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_symplectic_matrix_form</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">z</span><span class="si">}</span><span class="s2"> not a symplectic matrix&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_symplectic_matrix_form</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">matrix</span><span class="si">}</span><span class="s2"> not a GF(2) symplectic matrix&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_center</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">matrix</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">))):</span>
                <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span>
                    <span class="s2">&quot;When providing an input hyperbolic set </span><span class="se">\</span>
<span class="s2">                    the input matrix must be the center of the full set of </span><span class="se">\</span>
<span class="s2">                        generators&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;If matrix, x and z are None then n must be provided&quot;</span><span class="p">)</span>
            <span class="n">zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">augment_mat</span><span class="p">(</span><span class="n">zero</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">augment_mat</span><span class="p">(</span><span class="n">zero</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_symplectic_matrix_form</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">matrix</span><span class="si">}</span><span class="s2"> not a GF(2) symplectic matrix&quot;</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">return</span> <span class="n">_hyperbolic_basis_for_pauli_group</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_hyperbolic_basis_for_pauli_group</span><span class="p">(</span>
    <span class="n">matrix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">z</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Builds a hyperbolic basis for the associated Pauli group</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix (Optional): Input GF(2) symplectic matrix</span>
<span class="sd">        x, z (Optional): Input GF(2) hyperbolic pairs</span>

<span class="sd">    Returns:</span>
<span class="sd">        Hyperbolic basis for the associated Pauli group (new_x, new_z)</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; matrix = numpy.array([[0,1,0,0,1,0,1,0],</span>
<span class="sd">                               [0,0,0,0,1,1,0,1],</span>
<span class="sd">                               [1,1,1,0,0,1,0,0],</span>
<span class="sd">                               [1,1,0,1,0,0,0,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; center_, x, z = make_isotropic_hyperbolic_form(matrix)</span>
<span class="sd">        &gt;&gt;&gt; nx, nz = _hyperbolic_basis_for_pauli_group(center_, x, z)</span>
<span class="sd">        &gt;&gt;&gt; nx.astype(int)</span>
<span class="sd">        array([[0, 1, 0, 0, 1, 0, 1, 0],</span>
<span class="sd">               [1, 0, 0, 1, 0, 1, 1, 1],</span>
<span class="sd">               [1, 1, 1, 0, 1, 0, 0, 1],</span>
<span class="sd">               [1, 0, 1, 1, 0, 0, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; nz.astype(int)</span>
<span class="sd">        array([[0, 0, 0, 0, 1, 1, 0, 1],</span>
<span class="sd">               [0, 0, 0, 0, 1, 0, 1, 0],</span>
<span class="sd">               [0, 1, 0, 1, 0, 0, 0, 0],</span>
<span class="sd">               [0, 1, 0, 1, 0, 0, 1, 0]])</span>

<span class="sd">        &gt;&gt;&gt; matrix = numpy.array([[0,1,0,0,1,0,1,0],</span>
<span class="sd">                               [0,0,0,0,1,1,0,1],</span>
<span class="sd">                               [1,1,1,0,0,1,0,0],</span>
<span class="sd">                               [1,1,0,1,0,0,0,0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; nx, nz = _hyperbolic_basis_for_pauli_group(matrix)</span>
<span class="sd">        array([[0, 1, 0, 0, 1, 0, 1, 0],</span>
<span class="sd">               [1, 0, 0, 1, 0, 1, 1, 1],</span>
<span class="sd">               [1, 1, 1, 0, 1, 0, 0, 1],</span>
<span class="sd">               [1, 0, 1, 1, 0, 0, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; nz.astype(int)</span>
<span class="sd">        array([[0, 0, 0, 0, 1, 1, 0, 1],</span>
<span class="sd">               [0, 0, 0, 0, 1, 0, 1, 0],</span>
<span class="sd">               [0, 1, 0, 1, 0, 0, 0, 0],</span>
<span class="sd">               [0, 1, 0, 1, 0, 0, 1, 0]])</span>

<span class="sd">        &gt;&gt;&gt; x = numpy.array([[0, 1, 0, 0, 1, 0, 1, 0]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; z = numpy.array([[0, 0, 0, 0, 1, 1, 0, 1]], dtype=numpy.bool_)</span>
<span class="sd">        &gt;&gt;&gt; nx, nz = _hyperbolic_basis_for_pauli_group(x=x, z=z)</span>
<span class="sd">        &gt;&gt;&gt; nx.astype(int)</span>
<span class="sd">        array([[0, 1, 0, 0, 1, 0, 1, 0],</span>
<span class="sd">               [1, 1, 0, 0, 0, 1, 1, 1],</span>
<span class="sd">               [1, 1, 1, 0, 0, 0, 0, 0],</span>
<span class="sd">               [0, 1, 0, 1, 0, 0, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; nz.astype(int)</span>
<span class="sd">        array([[0, 0, 0, 0, 1, 1, 0, 1],</span>
<span class="sd">               [0, 0, 0, 0, 1, 0, 1, 0],</span>
<span class="sd">               [0, 0, 0, 0, 0, 0, 1, 0],</span>
<span class="sd">               [0, 0, 0, 0, 0, 0, 0, 1]])</span>

<span class="sd">    See Also:</span>
<span class="sd">    hyperbolic_basis_for_pauli_group</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">center_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">_symplectic_gram_schmidt</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">center_</span> <span class="o">=</span> <span class="n">matrix</span>

    <span class="k">if</span> <span class="n">center_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">_make_hyperbolic</span><span class="p">(</span><span class="n">center_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

    <span class="n">basis</span> <span class="o">=</span> <span class="n">_basis_for_pauli_group</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)))</span>
    <span class="n">added</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">basis_com</span> <span class="o">=</span> <span class="n">_make_commute_hyper</span><span class="p">(</span><span class="n">basis</span><span class="p">[</span><span class="o">-</span><span class="n">added</span><span class="p">:],</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">x_new</span><span class="p">,</span> <span class="n">z_new</span> <span class="o">=</span> <span class="n">symplectic_gram_schmidt</span><span class="p">(</span><span class="n">basis_com</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x_new</span><span class="p">,</span> <span class="n">z_new</span>


<span class="k">def</span><span class="w"> </span><span class="nf">remove_hyper_elements_from_hyper_form</span><span class="p">(</span>
    <span class="n">center_</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Transfers those elements/vectors from x with an index in indices into center_</span>
<span class="sd">    and deletes the corresponding hyperbolic partner from z.</span>

<span class="sd">    Args:</span>
<span class="sd">        center_: center array</span>
<span class="sd">        x: Hyperbolic pairs, x being the source</span>
<span class="sd">        z: Hyperbolic pairs, x being the source</span>
<span class="sd">        indices: indices indicating which rows to transfer from source to sink</span>

<span class="sd">    Raises:</span>
<span class="sd">        QiskitError: x and z must be GF(2) symplectic matrices/vectors</span>
<span class="sd">        QiskitError: x and z must have the same shape</span>
<span class="sd">        QiskitError: x and z must have the same size in the second</span>
<span class="sd">                dimension as the center</span>

<span class="sd">    Returns:</span>
<span class="sd">        isotropic hyperbolic basis (center, x, z)</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; x, z = sysp.hyperbolic_basis_for_pauli_group(n=5)</span>
<span class="sd">        &gt;&gt;&gt; center_, x_new, z_new = remove_hyper_elements_from_hyper_form(None,x,z,[0,1])</span>
<span class="sd">        &gt;&gt;&gt; center_.astype(int)</span>
<span class="sd">        array([[1, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">               [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; x_new.astype(int)</span>
<span class="sd">        array([[0, 0, 0, 0, 1, 0, 0, 0, 0, 0],</span>
<span class="sd">              [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">              [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; z_new.astype(int)</span>
<span class="sd">        array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 1],</span>
<span class="sd">              [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],</span>
<span class="sd">              [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">is_symplectic_matrix_form</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_symplectic_matrix_form</span><span class="p">(</span><span class="n">z</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;x and z must be GF(2) symplectic matrices/vectors&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;x (shape=</span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">)and z (shape=</span><span class="si">{</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">) </span><span class="se">\</span>
<span class="s2">            must have the same shape&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">center_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">center_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">center_</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_symplectic_matrix_form</span><span class="p">(</span><span class="n">center_</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;Input center is not a GF(2) symplectiv matrix/vector&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">center_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span>
                <span class="s2">&quot;x and z must have the same size in the second </span><span class="se">\</span>
<span class="s2">                dimension as the center&quot;</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">_remove_hyper_elements_from_hyper_form</span><span class="p">(</span><span class="n">center_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_remove_hyper_elements_from_hyper_form</span><span class="p">(</span>
    <span class="n">center_</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Transfers those elements/vectors from x with an index in indices into center_</span>
<span class="sd">    and delete the corresponding hyperbolic partner from z.</span>

<span class="sd">    Args:</span>
<span class="sd">        center_: center array</span>
<span class="sd">        x, z: Hyperbolic pairs, x being the source</span>
<span class="sd">        indices: indices indicating which rows to transfer from source to sink</span>

<span class="sd">    Returns:</span>
<span class="sd">        isotropic hyperbolic basis (center, x, z)</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; x, z = sysp.hyperbolic_basis_for_pauli_group(n=5)</span>
<span class="sd">        &gt;&gt;&gt; center_, x_new, z_new = _remove_hyper_elements_from_hyper_form(None,x,z,[0,1])</span>
<span class="sd">        &gt;&gt;&gt; center_.astype(int)</span>
<span class="sd">        array([[1, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">               [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; x_new.astype(int)</span>
<span class="sd">        array([[0, 0, 0, 0, 1, 0, 0, 0, 0, 0],</span>
<span class="sd">              [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">              [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; z_new.astype(int)</span>
<span class="sd">        array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 1],</span>
<span class="sd">              [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],</span>
<span class="sd">              [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">rm_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rm_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">rm_size</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">new_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
    <span class="n">new_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">part_center</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">part_center</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_x</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_z</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">part_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">part_center</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">center_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">new_center</span> <span class="o">=</span> <span class="n">part_center</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">center_</span><span class="p">,</span> <span class="n">part_center</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">new_center</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">new_center</span> <span class="o">=</span> <span class="n">new_center</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">new_center</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">new_center</span><span class="p">,</span> <span class="n">new_x</span><span class="p">,</span> <span class="n">new_z</span>


<span class="k">def</span><span class="w"> </span><span class="nf">min_generating</span><span class="p">(</span>
    <span class="n">matrix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">z</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a minimal generating/linearily independent set of rows.</span>

<span class="sd">    If only a matrix is provided, the method returns a submatrix with maximally</span>
<span class="sd">    independent set of rows. If a matrix and a set of hyperbolic pairs are provided then</span>
<span class="sd">    the method returns a submatrix such that the rows of the submatrix and the</span>
<span class="sd">    hyperbolic pairs are maximally linearily independent.</span>

<span class="sd">    Note: This method returns matrix as a 2d matrix (relative to numpy)</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix (Optional[np.ndarray]): Input GF(2) symplectic matrix</span>
<span class="sd">        x (Optional[np.ndarray]): Input hyperbolic set - pair of GF(2) symplectic matrices</span>
<span class="sd">        z (Optional[np.ndarray]): Input hyperbolic set - pair of GF(2) symplectic matrices</span>

<span class="sd">    Raises:</span>
<span class="sd">        QiskitError: An input matrix is required</span>
<span class="sd">        QiskitError: Inputs x and z matrices do not have the same shape</span>
<span class="sd">        QiskitError: Input hyper pair matrices do not represent a set of Hyperbolic pairs</span>
<span class="sd">        QiskitError: Input matrix and x and z components must have the same number of columns</span>

<span class="sd">    Returns:</span>
<span class="sd">        matrix: minimal generating set or rows</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; mat = numpy.array([[1,0,1,0],[1,1,0,1],[0,1,1,1]])</span>
<span class="sd">        &gt;&gt;&gt; res = min_generating(mat)</span>
<span class="sd">        &gt;&gt;&gt; res.astype(int)</span>
<span class="sd">        array([[1,0,1,0],</span>
<span class="sd">               [1,1,0,1]])</span>

<span class="sd">        &gt;&gt;&gt; mat = numpy.array([[1,0,1,0],[1,1,0,1],[0,1,1,1]])</span>
<span class="sd">        &gt;&gt;&gt; x = numpy.array([[0,1,0,0]])</span>
<span class="sd">        &gt;&gt;&gt; z = numpy.array([[0,0,0,1]])</span>
<span class="sd">        &gt;&gt;&gt; res = symp.min_generating(mat,x,z)</span>
<span class="sd">        &gt;&gt;&gt; res.astype(int)</span>
<span class="sd">        array([[1, 0, 1, 0],</span>
<span class="sd">               [1, 1, 0, 1]])</span>

<span class="sd">    See Also:</span>
<span class="sd">        _min_generating_matrix, _min_generating_matrix_xz</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># all inputs are None</span>

    <span class="k">if</span> <span class="n">matrix</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;An input matrix is required&quot;</span><span class="p">)</span>

    <span class="c1"># Only matrix is provided</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_min_generating_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

    <span class="c1"># Only x and z are provided</span>
    <span class="k">if</span> <span class="n">matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;An input matrix is required&quot;</span><span class="p">)</span>

    <span class="c1"># All matrix, x and z are provided</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;Inputs x and z matrices do not have the same shape&quot;</span><span class="p">)</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span>
            <span class="s2">&quot;Input matrix and x and z components must have the same number of columns&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">_min_generating_matrix_xz</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_min_generating_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a matrix consisting of rows from the input matrix such that the resulting</span>
<span class="sd">    matrix and the input matrix have the same rank.</span>

<span class="sd">    Note: This method returns everything as 2d matrices</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix: Input GF(2) symplectic matrix</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; mat = numpy.array([[1,0,1,0],[1,1,0,1],[0,1,1,1],[1,1,1,1],[0,0,0,0]])</span>
<span class="sd">        &gt;&gt;&gt; _min_generating_matrix(mat)</span>
<span class="sd">        array([[1, 0, 1, 0],</span>
<span class="sd">               [1, 1, 0, 1],</span>
<span class="sd">               [0, 1, 1, 1]])</span>

<span class="sd">    Returns:</span>
<span class="sd">        matrix: submatrix of input matrix with full rank</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">heads</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">rank_</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">rref_complete</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rank_</span> <span class="o">==</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">matrix</span>

    <span class="n">posns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">heads</span><span class="p">)</span>
    <span class="n">ext_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">posns</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">posns</span><span class="p">):</span>
        <span class="n">ext_matrix</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ext_matrix</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_min_generating_matrix_xz</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a submatrix of the input matrix such that combined rows of the submatrix and the</span>
<span class="sd">    hyperbolic pairs are linearily independent of GF(2)</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix: GF(2) symplectic matrix</span>
<span class="sd">        x, y: hyperbolic basis pairs</span>

<span class="sd">    Returns:</span>
<span class="sd">        matrix: Submatrix of input matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Priority is given to preserving the hyperbolic set (x,z) and so matrix is stack on the bottom.</span>
    <span class="n">tmp_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">matrix</span><span class="p">))</span>
    <span class="n">heads</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">rank_</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">rref_complete</span><span class="p">(</span><span class="n">tmp_matrix</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rank_</span> <span class="o">&lt;</span> <span class="n">tmp_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="c1"># Since (x,z) has already been reduced any removal will appear in the matrix part</span>
        <span class="n">posns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">heads</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:])</span>
        <span class="n">ext_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">posns</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">posns</span><span class="p">):</span>
            <span class="n">ext_matrix</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">ext_matrix</span>
    <span class="k">return</span> <span class="n">matrix</span>


<span class="k">def</span><span class="w"> </span><span class="nf">normalizer</span><span class="p">(</span>
    <span class="n">matrix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">z</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">min_gen</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the normalizer of the group generated by the generators represented in the</span>
<span class="sd">    symplectic matrix(s):</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix (optional): GF(2) symplectic matrix. Defaults to None.</span>
<span class="sd">        x (optional): Hyperbolic pairs. Defaults to None.</span>
<span class="sd">        z (optional): Hyperbolic pairs. Defaults to None.</span>
<span class="sd">        min_gen (optional): If True then the matrix will be reduced to be full</span>
<span class="sd">            rank (i.e. the rows will be a minimal generating set). Default is False</span>

<span class="sd">    Raises:</span>
<span class="sd">        QiskitError: All inputs should not be None</span>
<span class="sd">        QiskitError: matrix must be a GF(2) symplectic matrix</span>
<span class="sd">        QiskitError: x and z must be both be None or both be array like</span>
<span class="sd">        QiskitError: x and z must be GF(2) symplectic matrices/vectors</span>
<span class="sd">        QiskitError: x and z must have the same shape</span>
<span class="sd">        QiskitError: All inputs must have the same number of columns/length</span>

<span class="sd">    Returns:</span>
<span class="sd">        Isotropic hyperbolic form/basis of normalizer (center, x_new, y_new)</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; a = np.array([[1, 1, 1, 0, 1, 0, 0, 1]], dtype=np.bool_)</span>
<span class="sd">        &gt;&gt;&gt; x = np.array([[0, 1, 0, 0, 1, 0, 1, 0]], dtype=np.bool_)</span>
<span class="sd">        &gt;&gt;&gt; z = np.array([[0, 0, 0, 0, 1, 1, 0, 1]], dtype=np.bool_)</span>
<span class="sd">        &gt;&gt;&gt; center_, x_new, z_new = sysp.normalizer(a, x, z)</span>
<span class="sd">        &gt;&gt;&gt; center_.astype(int)</span>
<span class="sd">        array([[1, 1, 1, 0, 1, 0, 0, 1]])</span>
<span class="sd">        &gt;&gt;&gt; x_new.astype(int)</span>
<span class="sd">        array([[1, 0, 1, 1, 0, 0, 0, 0],</span>
<span class="sd">               [1, 1, 1, 0, 0, 0, 1, 1],</span>
<span class="sd">               [0, 1, 0, 0, 1, 0, 1, 0]])</span>
<span class="sd">        &gt;&gt;&gt; z_new.astype(int)</span>
<span class="sd">        array([[1, 1, 1, 0, 1, 0, 0, 0],</span>
<span class="sd">               [1, 1, 0, 0, 0, 1, 0, 0],</span>
<span class="sd">               [0, 0, 0, 0, 1, 1, 0, 1]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">matrix</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;All inputs should not be None&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_symplectic_matrix_form</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">matrix</span><span class="si">}</span><span class="s2"> must be a GF(2) symplectic matrix&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;x and z must be both be None or both be array like&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">min_gen</span><span class="p">:</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">min_generating</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_stabilizer_group</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_normalizer_abelian_group</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_normailzer_group</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">is_symplectic_matrix_form</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_symplectic_matrix_form</span><span class="p">(</span><span class="n">z</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;x and z must be GF(2) symplectic matrices/vectors&quot;</span><span class="p">)</span>

    <span class="n">zero_mat</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        <span class="n">zero_mat</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;x and z must have the same shape&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;All inputs must have the same number of columns/length&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_center</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">matrix</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">))):</span>
        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span>
            <span class="s2">&quot;When a matrix and hyperbolic parts are &quot;</span>
            <span class="s2">&quot;provided the matrix must represent the center of the union&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">zero_mat</span><span class="p">:</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">min_generating</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_normalizer_group_preserve</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_normalizer_abelian_group</span><span class="p">(</span>
    <span class="n">matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the normalizer of the abelian group generated by the generators represented in the</span>
<span class="sd">    symplectic matrix(s):</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix (optional): GF(2) symplectic matrix. Defaults to None.</span>
<span class="sd">        x, z  (optional): Hyperbolic pairs. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Isotropic hyperbolic form/basis of normalizer (center, x_new, y_new)</span>

<span class="sd">    TODO: Add examples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dist_center</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

    <span class="n">matrix_ext</span> <span class="o">=</span> <span class="n">_basis_for_pauli_group</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
    <span class="n">center_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">_symplectic_gram_schmidt</span><span class="p">(</span><span class="n">matrix_ext</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[])</span>
    <span class="n">center_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">_remove_hyper_elements_from_hyper_form</span><span class="p">(</span><span class="n">center_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dist_center</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">center_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">center_</span> <span class="o">=</span> <span class="n">center_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">center_</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">center_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_normalizer_group_preserve</span><span class="p">(</span>
    <span class="n">center_</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the normalizer of the group generated by the generators represented in the</span>
<span class="sd">    symplectic matrix(s) and trys to preserve elements:</span>

<span class="sd">    This method assumes that the matrix has full rank. That is that the</span>
<span class="sd">    set of generators is independent.</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix (optional): GF(2) symplectic matrix. Defaults to None.</span>
<span class="sd">        x, z  (optional): Hyperbolic pairs. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Isotropic hyperbolic form/basis of normalizer (center, x_new, y_new)</span>

<span class="sd">    TODO: Add examples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">center_size</span> <span class="o">=</span> <span class="n">center_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">center_size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">center_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">center_size</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">gauge_degree</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">center_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">_make_hyperbolic</span><span class="p">(</span><span class="n">center_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

    <span class="n">matrix_ext</span> <span class="o">=</span> <span class="n">_basis_for_pauli_group</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)))</span>
    <span class="n">matrix_ext</span> <span class="o">=</span> <span class="n">make_commute_hyper</span><span class="p">(</span><span class="n">matrix_ext</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">matrix_ext</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="c1"># matrix_ext = _make_elements_commute_with_hyper_pairs(</span>
    <span class="c1">#    matrix_ext,</span>
    <span class="c1">#    range(x.shape[0] &lt;&lt; 1, matrix_ext.shape[0]),</span>
    <span class="c1">#    x,</span>
    <span class="c1">#    range(x.shape[0]),</span>
    <span class="c1">#    z,</span>
    <span class="c1">#    range(z.shape[0]),</span>
    <span class="c1"># )</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">matrix_ext</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="p">:]</span>
    <span class="n">lx</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">matrix_ext</span><span class="p">[:</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
    <span class="n">lz</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">matrix_ext</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">]]</span>
    <span class="n">center_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">_symplectic_gram_schmidt</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">lx</span><span class="p">,</span> <span class="n">lz</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">gauge_degree</span><span class="p">,</span> <span class="n">gauge_degree</span> <span class="o">+</span> <span class="n">center_size</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">_remove_hyper_elements_from_hyper_form</span><span class="p">(</span><span class="n">center_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_normailzer_group</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the normalizer of the group generated by the generators represented in the</span>
<span class="sd">    symplectic matrix(s):</span>

<span class="sd">    This method assumes that the matrix has full rank. That is that the</span>
<span class="sd">    set of generators is independent.</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix: GF(2) Sympletic matrix</span>

<span class="sd">    Returns:</span>
<span class="sd">        Isotropic hyperbolic form/basis of normalizer (center, x_new, y_new)</span>

<span class="sd">    TODO: Add examples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">center_</span><span class="p">,</span> <span class="n">hyper1</span><span class="p">,</span> <span class="n">hyper2</span> <span class="o">=</span> <span class="n">_symplectic_gram_schmidt</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[])</span>

    <span class="k">return</span> <span class="n">_normalizer_group_preserve</span><span class="p">(</span><span class="n">center_</span><span class="p">,</span> <span class="n">hyper1</span><span class="p">,</span> <span class="n">hyper2</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_extend_symplectic</span><span class="p">(</span><span class="n">matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">extend</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">ext_part</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">extend</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">matrix</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">ext_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">matrix</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">],</span> <span class="n">ext_part</span><span class="p">,</span> <span class="n">matrix</span><span class="p">[:,</span> <span class="n">n</span><span class="p">:],</span> <span class="n">ext_part</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ext_matrix</span>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2022, Qiskit Development Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            <div class="last-updated">
              Last updated on 2025/01/27</div>
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../../_static/documentation_options.js?v=7026087e"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/furo.js?v=5fa4622c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    </body>
</html>