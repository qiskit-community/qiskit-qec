module MonteCarlo

using Dictionaries: Dictionary
using ..DictTools: _AbstractDict, count_map!, baretypeof
using Random
using ..TupleArrays

export one_sample, collect_samples, collect_samples!

"""
    one_sample(prob_map)

Generate one sample of applying bit flips randomly to a register initially
in the all zero state.

`prob_map` maps bitstrings to probabilities. The ones in each bitstring
represent a bit flip. Each bitstring is applied, or not, independently according
to its probability.
"""
@inline function one_sample(prob_map)
    state = zero(first(keys(prob_map)))
    for (_bits, p) in pairs(prob_map)
        rand() < p && (state = xor(state, _bits))
    end
    return state
end

one_sample(x::Union{Number,Tuple}...) = throw(MethodError(one_sample, x))

# temp disable just to check dispatch
function dis_one_sample(prob_map, info)
    state = zero(first(keys(prob_map)))
    num_errors = 0
    for (_bits, p) in pairs(prob_map)
        x = rand()
        if x < p
            state = xor(state, _bits)
            num_errors += 1
        end
    end
    return (num_errors, state)
end

# This should work when converted to normal array as well!
function one_sample(prob_map::AbstractTupleArray, info)
    state = zero(first(first(prob_map)))
    num_errors = 0
    for (_bits, p) in prob_map
        x = rand()
        if x < p
            state = xor(state, _bits)
            num_errors += 1
        end
    end
    return (num_errors, state)
end

"""
    one_sample(prob_map::AbstractTupleArray, info::Val{:all})

Return a sample including the observed state and all errors that contributed to it.
"""
function one_sample(prob_map::AbstractTupleArray, info::Val{:all})
    state = zero(first(first(prob_map)))
    accepted_states = typeof(state)[]
    for (_bits, p) in prob_map
        x = rand()
        if x < p
            state = xor(state, _bits)
            !iszero(_bits) && push!(accepted_states, _bits) # why is zero here?
        end
    end
    return (accepted_states, state)
end

"""
    one_sample!(buf, prob_map)

The same as `one_sample`, except that `buf` is
a `Vector{Float64}` of length equal to the number of
keys in `prob_map`. The buffer is repeatedly filled
with random numbers.
"""
@inline function one_sample!(buf, prob_map)
    state = zero(first(keys(prob_map)))
    rand!(buf)
    for (i, (_bits, p)) in enumerate(pairs(prob_map))
        @inbounds buf[i] < p && (state = xor(state, _bits))
    end
    return state
end

"""
    one_sample_num_errors!(buf, prob_map)

Sample the number of errors (bitstrings) that occur.
"""
function one_sample_num_errors!(buf, prob_map)
    rand!(buf)
    n_errors = 0
    for (i, (_bits, p)) in enumerate(pairs(prob_map))
        @inbounds if buf[i] < p
            n_errors += 1
        end
    end
    return n_errors
end


"""
    collect_samples(nsamp::Integer, probs::_AbstractDict{T}, samp_func = one_sample!)
Sample observed strings and generate a count map of the results.

The keys are bitstrings (as integers) and values are the number of times the
string was observed. Samples are generated via Monte Carlo. Each sample is
generated by randomly applying each error with its specified probability. Note
that several error combinations may give rise to the same observed bit
string. This information is lost in `samp_map`.

See `one_sample`.
"""
function collect_samples(nsamp::Integer, probs::_AbstractDict{T},
                         samp_func = one_sample!
                         ) where T
    return collect_samples!(baretypeof(probs){T,Int}(), nsamp, probs, samp_func)
end

function collect_samples!(results::_AbstractDict, nsamp::Integer, probs,
                          samp_func = one_sample!)
    KeyT = typeof(first(keys(probs)))
    _zero = zero(Int)
    buf = zeros(length(probs))
    for _ in 1:nsamp
        state = samp_func(buf, probs)
        count_map!(results, state)
    end
    return results
end

# Need to fix this so it works with arrays
# function collect_samples(nsamp::Integer, probs::_AbstractDict{T},
#                          samp_func = one_sample!
#                          ) where T
#     return collect_samples!(baretypeof(probs){T,Int}(), nsamp, probs, samp_func)
# end
# function collect_samples!(results::_AbstractDict, nsamp::Integer, probs,
#                           samp_func = one_sample!)
#     KeyT = typeof(first(keys(probs)))
#     _zero = zero(Int)
#     buf = zeros(length(probs))
#     for _ in 1:nsamp
#         state = samp_func(buf, probs)
#         count_map!(results, state)
#     end
#     return results
# end


end # module MonteCarlo
